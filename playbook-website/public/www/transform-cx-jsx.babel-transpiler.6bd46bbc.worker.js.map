{"version":3,"sources":["webpack:////Users/jasper.furniss/codesandbox-client/node_modules/babel-plugin-syntax-jsx/lib/index.js","webpack:////Users/jasper.furniss/codesandbox-client/node_modules/babel-plugin-transform-cx-jsx/index.js"],"names":["exports","__esModule","default","manipulateOptions","opts","parserOpts","plugins","push","module","dashRegex","property","t","name","value","namespace","objectProperty","stringLiteral","objectExpression","result","exec","processAttribute","attribute","options","type","booleanLiteral","processChild","root","scope","child","processElement","expression","i","properties","length","elements","element","openingElement","children","tagName","elementName","object","Error","filter","c","map","attributes","jSXAttribute","jSXIdentifier","jSXExpressionContainer","arrayExpression","nullLiteral","attrs","dotIndex","indexOf","memberExpression","identifier","substr","substring","toLowerCase","autoImportHtmlElement","$cx","addImport","attrNames","spread","isJSXSpreadAttribute","argument","a","key","types","visitor","Program","enter","path","imports","importPath","importDeclaration","importSpecifier","unshiftContainer","exit","JSXElement","node","config","replaceWith","ArrowFunctionExpression","body","markedAsFunctionalComponentType","transformFunctionalComponents","callExpression","imported","inherits"],"mappings":"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","file":"transform-cx-jsx.babel-transpiler.6bd46bbc.worker.js","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\n\nexports.default = function () {\n  return {\n    manipulateOptions: function manipulateOptions(opts, parserOpts) {\n      parserOpts.plugins.push(\"jsx\");\n    }\n  };\n};\n\nmodule.exports = exports[\"default\"];","\"use strict\";\n\nlet dashRegex = /(.*)-(bind|tpl|expr)$/;\n\nfunction property(t, name, value) {\n   if (name.namespace && name.namespace.name) {\n      return t.objectProperty(t.stringLiteral(name.namespace.name), t.objectExpression([\n         t.objectProperty(t.stringLiteral(name.name.name), value)\n      ]));\n   }\n\n   let result = dashRegex.exec(name.name);\n   if (result)\n      return t.objectProperty(t.stringLiteral(result[1]), t.objectExpression([t.objectProperty(t.stringLiteral(result[2]), value)]));\n\n\n   return t.objectProperty(t.stringLiteral(name.name), value);\n}\n\nfunction elementName(name) {\n   if (name.name)\n      return name.name;\n   if (name.object)\n      return elementName(name.object) + '.' + elementName(name.property);\n   throw new Error('Could not calculate name.');\n}\n\nfunction processAttribute(t, attribute, options) {\n   if (attribute.type === 'JSXAttribute') {\n\n      if (attribute.value == null)\n         return property(t, attribute.name, t.booleanLiteral(true));\n\n      return property(t, attribute.name, processChild(t, attribute.value, { root: false, scope: options.scope }));\n   }\n\n   return false;\n}\n\nfunction processChild(t, child, options) {\n\n   if (!child)\n      return child;\n\n   switch (child.type) {\n      case 'JSXElement':\n         return processElement(t, child, options);\n\n      case 'JSXText':\n         return t.stringLiteral(child.value);\n\n      case 'JSXExpressionContainer':\n         return processChild(t, child.expression, options);\n\n      case 'ObjectExpression':\n         for (let i = 0; i < child.properties.length; i++)\n            child.properties[i].value = processChild(t, child.properties[i].value, options);\n         break;\n\n      case 'ArrayExpression':\n         for (let i = 0; i < child.elements.length; i++)\n            child.elements[i] = processChild(t, child.elements[i], options);\n         break;\n   }\n\n   return child;\n}\n\nfunction processElement(t, element, options) {\n   if (element.type === \"JSXElement\") {\n      if (element.openingElement) {\n         let tagName = elementName(element.openingElement.name);\n         if (tagName != \"cx\" && tagName != \"Cx\" && options.root)\n            return false;\n\n         let children;\n\n         if (options.root || tagName == 'cx' || tagName == 'Cx') {\n            options.root = false;\n\n            if (element.children != null)\n               children = element.children\n                  .filter(function (c) {\n                     return c.type == \"JSXElement\"\n                  })\n                  .map(function (c) {\n                     return processElement(t, c, options)\n                  });\n\n            if (tagName == 'Cx') {\n               if (children && children.length > 0)\n                  element.openingElement.attributes.push(t.jSXAttribute(t.jSXIdentifier('items'), t.jSXExpressionContainer(t.arrayExpression(children))));\n               element.children = [];\n               return element;\n            }\n\n            if (children && children.length > 1)\n               return t.arrayExpression(children);\n\n            if (children && children.length == 1)\n               return children[0];\n\n            return t.nullLiteral();\n         }\n\n         let attrs = [];\n\n         let dotIndex = tagName.indexOf('.');\n         if (dotIndex != -1)\n            attrs.push(t.objectProperty(t.stringLiteral('$type'), t.memberExpression(\n               t.identifier(tagName.substr(0, dotIndex)), t.identifier(tagName.substring(dotIndex + 1)))));\n         else if (tagName[0].toLowerCase() == tagName[0]) {\n            attrs.push(t.objectProperty(t.stringLiteral('$type'), t.identifier('HtmlElement')));\n            attrs.push(t.objectProperty(t.stringLiteral('tag'), t.stringLiteral(tagName)));\n            if (!options.scope.opts || options.scope.opts.autoImportHtmlElement !== false)\n               options.scope.$cx.addImport(\"HtmlElement\", \"cx/widgets\");\n         } else\n            attrs.push(t.objectProperty(t.stringLiteral('$type'), t.identifier(tagName)));\n\n         let attrNames = [];\n\n         let spread = [];\n\n         if (element.openingElement.attributes && element.openingElement.attributes.length) {\n            for (let i = 0; i < element.openingElement.attributes.length; i++) {\n               if (t.isJSXSpreadAttribute(element.openingElement.attributes[i])) {\n                  spread.push(element.openingElement.attributes[i].argument);\n               }\n               else {\n                  let a = processAttribute(t, element.openingElement.attributes[i], options);\n                  if (a) {\n                     attrs.push(a);\n                     attrNames.push(a.key.value);\n                  }\n               }\n            }\n         }\n\n         if (spread.length > 0)\n            attrs.push(t.objectProperty(t.stringLiteral('jsxSpread'), t.arrayExpression(spread)));\n\n         if (attrNames.length > 0)\n            attrs.push(t.objectProperty(t.stringLiteral('jsxAttributes'), t.arrayExpression(attrNames.map(function (name) {\n               return t.stringLiteral(name)\n            }))));\n\n         if (element.children != null && element.children.length) {\n            children = [];\n            for (let i = 0; i < element.children.length; i++) {\n               let c = processChild(t, element.children[i], options);\n               if (c)\n                  children.push(c);\n            }\n            if (children.length)\n               attrs.push(t.objectProperty(t.stringLiteral('children'), t.arrayExpression(children)));\n         }\n\n         return t.objectExpression(attrs);\n      }\n   }\n}\n\nmodule.exports = function(options) {\n   let t = options.types;\n\n   return {\n      visitor: {\n         Program: {\n            enter: function(path, scope) {\n               scope.$cx = {\n                  imports: {},\n                  addImport: function (name, importPath) {\n                     if (scope.$cx.imports[name])\n                        return;\n                     let identifier = t.identifier(name);\n                     let importDeclaration = t.importDeclaration([t.importSpecifier(identifier, identifier)], t.stringLiteral(importPath));\n                     path.unshiftContainer(\"body\", importDeclaration);\n                     scope.$cx.imports[name] = true;\n                  }\n               }\n            },\n            exit: function (path, scope) {\n               delete scope.$cx;\n            }\n         },\n\n         JSXElement: function(path, scope) {\n            let opts = scope.opts;\n            let node = path.node;\n\n            if (node.root) {\n               return;\n            }\n\n            let options = {\n               root: true,\n               scope: scope\n            };\n\n            let config = processElement(t, node, options, null);\n\n            if (config) {\n               path.replaceWith(config);\n               node.root = true;\n            }\n         },\n\n         ArrowFunctionExpression: function (path, scope) {\n            let node = path.node;\n            //register cx functional components ({props} => <cx><div /></cx>)\n            if (node.body.type === 'JSXElement' && node.body.openingElement.name.name === 'cx' && !node.markedAsFunctionalComponentType) {\n               if (!scope.opts || scope.opts.transformFunctionalComponents !== false) {\n                  scope.$cx.addImport(\"createFunctionalComponent\", \"cx/ui\");\n                  node.markedAsFunctionalComponentType = true;\n                  path.replaceWith(t.callExpression(t.identifier(\"createFunctionalComponent\"), [node]));\n               }\n            }\n         },\n\n         ImportSpecifier(path, scope) {\n            if (path.node.imported && scope.$cx) {\n               scope.$cx.imports[path.node.imported.name] = true;\n            }\n         }\n      },\n      inherits: require(\"babel-plugin-syntax-jsx\")\n   }\n};\n"],"sourceRoot":""}