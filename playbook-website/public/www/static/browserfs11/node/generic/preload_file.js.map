{"version":3,"file":"preload_file.js","sourceRoot":"","sources":["../../../src/generic/preload_file.ts"],"names":[],"mappings":"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","sourcesContent":["import {BaseFile, File} from '../core/file';\nimport {FileSystem, BFSOneArgCallback, BFSCallback, BFSThreeArgCallback} from '../core/file_system';\nimport Stats from '../core/node_fs_stats';\nimport {FileFlag} from '../core/file_flag';\nimport {ApiError, ErrorCode} from '../core/api_error';\nimport fs from '../core/node_fs';\nimport {emptyBuffer} from '../core/util';\n\n/**\n * An implementation of the File interface that operates on a file that is\n * completely in-memory. PreloadFiles are backed by a Buffer.\n *\n * This is also an abstract class, as it lacks an implementation of 'sync' and\n * 'close'. Each filesystem that wishes to use this file representation must\n * extend this class and implement those two methods.\n * @todo 'close' lever that disables functionality once closed.\n */\nexport default class PreloadFile<T extends FileSystem> extends BaseFile {\n  protected _fs: T;\n  private _pos: number = 0;\n  private _path: string;\n  private _stat: Stats;\n  private _flag: FileFlag;\n  private _buffer: Buffer;\n  private _dirty: boolean = false;\n  /**\n   * Creates a file with the given path and, optionally, the given contents. Note\n   * that, if contents is specified, it will be mutated by the file!\n   * @param _fs The file system that created the file.\n   * @param _path\n   * @param _mode The mode that the file was opened using.\n   *   Dictates permissions and where the file pointer starts.\n   * @param _stat The stats object for the given file.\n   *   PreloadFile will mutate this object. Note that this object must contain\n   *   the appropriate mode that the file was opened as.\n   * @param contents A buffer containing the entire\n   *   contents of the file. PreloadFile will mutate this buffer. If not\n   *   specified, we assume it is a new file.\n   */\n  constructor(_fs: T, _path: string, _flag: FileFlag, _stat: Stats, contents?: Buffer) {\n    super();\n    this._fs = _fs;\n    this._path = _path;\n    this._flag = _flag;\n    this._stat = _stat;\n    this._buffer = contents ? contents : emptyBuffer();\n    // Note: This invariant is *not* maintained once the file starts getting\n    // modified.\n    // Note: Only actually matters if file is readable, as writeable modes may\n    // truncate/append to file.\n    if (this._stat.size !== this._buffer.length && this._flag.isReadable()) {\n      throw new Error(`Invalid buffer: Buffer is ${this._buffer.length} long, yet Stats object specifies that file is ${this._stat.size} long.`);\n    }\n  }\n\n  /**\n   * NONSTANDARD: Get the underlying buffer for this file. !!DO NOT MUTATE!! Will mess up dirty tracking.\n   */\n  public getBuffer(): Buffer {\n    return this._buffer;\n  }\n\n  /**\n   * NONSTANDARD: Get underlying stats for this file. !!DO NOT MUTATE!!\n   */\n  public getStats(): Stats {\n    return this._stat;\n  }\n\n  public getFlag(): FileFlag {\n    return this._flag;\n  }\n\n  /**\n   * Get the path to this file.\n   * @return [String] The path to the file.\n   */\n  public getPath(): string {\n    return this._path;\n  }\n\n  /**\n   * Get the current file position.\n   *\n   * We emulate the following bug mentioned in the Node documentation:\n   * > On Linux, positional writes don't work when the file is opened in append\n   *   mode. The kernel ignores the position argument and always appends the data\n   *   to the end of the file.\n   * @return [Number] The current file position.\n   */\n  public getPos(): number {\n    if (this._flag.isAppendable()) {\n      return this._stat.size;\n    }\n    return this._pos;\n  }\n\n  /**\n   * Advance the current file position by the indicated number of positions.\n   * @param [Number] delta\n   */\n  public advancePos(delta: number): number {\n    return this._pos += delta;\n  }\n\n  /**\n   * Set the file position.\n   * @param [Number] newPos\n   */\n  public setPos(newPos: number): number {\n    return this._pos = newPos;\n  }\n\n  /**\n   * **Core**: Asynchronous sync. Must be implemented by subclasses of this\n   * class.\n   * @param [Function(BrowserFS.ApiError)] cb\n   */\n  public sync(cb: BFSOneArgCallback): void {\n    try {\n      this.syncSync();\n      cb();\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  /**\n   * **Core**: Synchronous sync.\n   */\n  public syncSync(): void {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n\n  /**\n   * **Core**: Asynchronous close. Must be implemented by subclasses of this\n   * class.\n   * @param [Function(BrowserFS.ApiError)] cb\n   */\n  public close(cb: BFSOneArgCallback): void {\n    try {\n      this.closeSync();\n      cb();\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  /**\n   * **Core**: Synchronous close.\n   */\n  public closeSync(): void {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n\n  /**\n   * Asynchronous `stat`.\n   * @param [Function(BrowserFS.ApiError, BrowserFS.node.fs.Stats)] cb\n   */\n  public stat(cb: BFSCallback<Stats>): void {\n    try {\n      cb(null, Stats.clone(this._stat));\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  /**\n   * Synchronous `stat`.\n   */\n  public statSync(): Stats {\n    return Stats.clone(this._stat);\n  }\n\n  /**\n   * Asynchronous truncate.\n   * @param [Number] len\n   * @param [Function(BrowserFS.ApiError)] cb\n   */\n  public truncate(len: number, cb: BFSOneArgCallback): void {\n    try {\n      this.truncateSync(len);\n      if (this._flag.isSynchronous() && !fs.getRootFS()!.supportsSynch()) {\n        this.sync(cb);\n      }\n      cb();\n    } catch (e) {\n      return cb(e);\n    }\n  }\n\n  /**\n   * Synchronous truncate.\n   * @param [Number] len\n   */\n  public truncateSync(len: number): void {\n    this._dirty = true;\n    if (!this._flag.isWriteable()) {\n      throw new ApiError(ErrorCode.EPERM, 'File not opened with a writeable mode.');\n    }\n    this._stat.mtimeMs = Date.now();\n    if (len > this._buffer.length) {\n      const buf = Buffer.alloc(len - this._buffer.length, 0);\n      // Write will set @_stat.size for us.\n      this.writeSync(buf, 0, buf.length, this._buffer.length);\n      if (this._flag.isSynchronous() && fs.getRootFS()!.supportsSynch()) {\n        this.syncSync();\n      }\n      return;\n    }\n    this._stat.size = len;\n    // Truncate buffer to 'len'.\n    const newBuff = Buffer.alloc(len);\n    this._buffer.copy(newBuff, 0, 0, len);\n    this._buffer = newBuff;\n    if (this._flag.isSynchronous() && fs.getRootFS()!.supportsSynch()) {\n      this.syncSync();\n    }\n  }\n\n  /**\n   * Write buffer to the file.\n   * Note that it is unsafe to use fs.write multiple times on the same file\n   * without waiting for the callback.\n   * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to\n   *  the file.\n   * @param [Number] offset Offset in the buffer to start reading data from.\n   * @param [Number] length The amount of bytes to write to the file.\n   * @param [Number] position Offset from the beginning of the file where this\n   *   data should be written. If position is null, the data will be written at\n   *   the current position.\n   * @param [Function(BrowserFS.ApiError, Number, BrowserFS.node.Buffer)]\n   *   cb The number specifies the number of bytes written into the file.\n   */\n  public write(buffer: Buffer, offset: number, length: number, position: number, cb: BFSThreeArgCallback<number, Buffer>): void {\n    try {\n      cb(null, this.writeSync(buffer, offset, length, position), buffer);\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  /**\n   * Write buffer to the file.\n   * Note that it is unsafe to use fs.writeSync multiple times on the same file\n   * without waiting for the callback.\n   * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to\n   *  the file.\n   * @param [Number] offset Offset in the buffer to start reading data from.\n   * @param [Number] length The amount of bytes to write to the file.\n   * @param [Number] position Offset from the beginning of the file where this\n   *   data should be written. If position is null, the data will be written at\n   *   the current position.\n   * @return [Number]\n   */\n  public writeSync(buffer: Buffer, offset: number, length: number, position: number): number {\n    this._dirty = true;\n    if (position === undefined || position === null) {\n      position = this.getPos();\n    }\n    if (!this._flag.isWriteable()) {\n      throw new ApiError(ErrorCode.EPERM, 'File not opened with a writeable mode.');\n    }\n    const endFp = position + length;\n    if (endFp > this._stat.size) {\n      this._stat.size = endFp;\n      if (endFp > this._buffer.length) {\n        // Extend the buffer!\n        const newBuff = Buffer.alloc(endFp);\n        this._buffer.copy(newBuff);\n        this._buffer = newBuff;\n      }\n    }\n    const len = buffer.copy(this._buffer, position, offset, offset + length);\n    this._stat.mtimeMs = Date.now();\n    if (this._flag.isSynchronous()) {\n      this.syncSync();\n      return len;\n    }\n    this.setPos(position + len);\n    return len;\n  }\n\n  /**\n   * Read data from the file.\n   * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be\n   *   written to.\n   * @param [Number] offset The offset within the buffer where writing will\n   *   start.\n   * @param [Number] length An integer specifying the number of bytes to read.\n   * @param [Number] position An integer specifying where to begin reading from\n   *   in the file. If position is null, data will be read from the current file\n   *   position.\n   * @param [Function(BrowserFS.ApiError, Number, BrowserFS.node.Buffer)] cb The\n   *   number is the number of bytes read\n   */\n  public read(buffer: Buffer, offset: number, length: number, position: number, cb: BFSThreeArgCallback<number, Buffer>): void {\n    try {\n      cb(null, this.readSync(buffer, offset, length, position), buffer);\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  /**\n   * Read data from the file.\n   * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be\n   *   written to.\n   * @param [Number] offset The offset within the buffer where writing will\n   *   start.\n   * @param [Number] length An integer specifying the number of bytes to read.\n   * @param [Number] position An integer specifying where to begin reading from\n   *   in the file. If position is null, data will be read from the current file\n   *   position.\n   * @return [Number]\n   */\n  public readSync(buffer: Buffer, offset: number, length: number, position: number): number {\n    if (!this._flag.isReadable()) {\n      throw new ApiError(ErrorCode.EPERM, 'File not opened with a readable mode.');\n    }\n    if (position === undefined || position === null) {\n      position = this.getPos();\n    }\n    const endRead = position + length;\n    if (endRead > this._stat.size) {\n      length = this._stat.size - position;\n    }\n    const rv = this._buffer.copy(buffer, offset, position, position + length);\n    this._stat.atimeMs = Date.now();\n    this._pos = position + length;\n    return rv;\n  }\n\n  /**\n   * Asynchronous `fchmod`.\n   * @param [Number|String] mode\n   * @param [Function(BrowserFS.ApiError)] cb\n   */\n  public chmod(mode: number, cb: BFSOneArgCallback): void {\n    try {\n      this.chmodSync(mode);\n      cb();\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  /**\n   * Asynchronous `fchmod`.\n   * @param [Number] mode\n   */\n  public chmodSync(mode: number): void {\n    if (!this._fs.supportsProps()) {\n      throw new ApiError(ErrorCode.ENOTSUP);\n    }\n    this._dirty = true;\n    this._stat.chmod(mode);\n    this.syncSync();\n  }\n\n  protected isDirty(): boolean {\n    return this._dirty;\n  }\n\n  /**\n   * Resets the dirty bit. Should only be called after a sync has completed successfully.\n   */\n  protected resetDirty() {\n    this._dirty = false;\n  }\n}\n\n/**\n * File class for the InMemory and XHR file systems.\n * Doesn't sync to anything, so it works nicely for memory-only files.\n */\nexport class NoSyncFile<T extends FileSystem> extends PreloadFile<T> implements File {\n  constructor(_fs: T, _path: string, _flag: FileFlag, _stat: Stats, contents?: Buffer) {\n    super(_fs, _path, _flag, _stat, contents);\n  }\n  /**\n   * Asynchronous sync. Doesn't do anything, simply calls the cb.\n   * @param [Function(BrowserFS.ApiError)] cb\n   */\n  public sync(cb: BFSOneArgCallback): void {\n    cb();\n  }\n  /**\n   * Synchronous sync. Doesn't do anything.\n   */\n  public syncSync(): void {\n    // NOP.\n  }\n  /**\n   * Asynchronous close. Doesn't do anything, simply calls the cb.\n   * @param [Function(BrowserFS.ApiError)] cb\n   */\n  public close(cb: BFSOneArgCallback): void {\n    cb();\n  }\n  /**\n   * Synchronous close. Doesn't do anything.\n   */\n  public closeSync(): void {\n    // NOP.\n  }\n}\n"]}