{"version":3,"file":"file_index.js","sourceRoot":"","sources":["../../../src/generic/file_index.ts"],"names":[],"mappings":"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","sourcesContent":["import * as path from 'path';\nimport {default as Stats, FileType} from '../core/node_fs_stats';\nimport { UNPKGMeta, UNPKGMetaDirectory } from '../backend/UNPKGRequest';\nimport { JSDelivrMeta } from '../backend/JSDelivrRequest';\n\n/**\n * A simple class for storing a filesystem index. Assumes that all paths passed\n * to it are *absolute* paths.\n *\n * Can be used as a partial or a full index, although care must be taken if used\n * for the former purpose, especially when directories are concerned.\n */\nexport class FileIndex<T> {\n  /**\n   * Static method for constructing indices from a JSON listing.\n   * @param listing Directory listing generated by tools/XHRIndexer.coffee\n   * @return A new FileIndex object.\n   */\n  public static fromListing<T>(listing: any): FileIndex<T> {\n    const idx = new FileIndex<T>();\n    // Add a root DirNode.\n    const rootInode = new DirInode<T>();\n    idx._index['/'] = rootInode;\n    const queue = [['', listing, rootInode]];\n    while (queue.length > 0) {\n      let inode: Inode;\n      const next = queue.pop();\n      const pwd = next![0];\n      const tree = next![1];\n      const parent = next![2];\n      for (const node in tree) {\n        if (tree.hasOwnProperty(node)) {\n          const children = tree[node];\n          const name = `${pwd}/${node}`;\n          if (children) {\n            idx._index[name] = inode = new DirInode<T>();\n            queue.push([name, children, inode]);\n          } else {\n            // This inode doesn't have correct size information, noted with -1.\n            inode = new FileInode<Stats>(new Stats(FileType.FILE, -1, 0x16D));\n          }\n          if (parent) {\n            parent._ls[node] = inode;\n          }\n        }\n      }\n    }\n    return idx;\n  }\n\n  public static fromUnpkg<T>(listing: UNPKGMeta): FileIndex<T> {\n    const idx = new FileIndex<T>();\n\n    function handleDir(dirPath: string, entry: UNPKGMetaDirectory) {\n      const dirInode: DirInode<T> = new DirInode<T>();\n      entry.files.forEach((child) => {\n        let inode: Inode;\n        if (child.type === 'file') {\n          inode = new FileInode<Stats>(new Stats(FileType.FILE, child.size));\n\n          // @ts-ignore\n          dirInode._ls[path.basename(child.path)] = inode;\n        } else {\n          idx._index[child.path] = inode = handleDir(child.path, child);\n        }\n      });\n\n      return dirInode;\n    }\n\n    idx._index['/'] = handleDir('/', listing);\n\n    return idx;\n  }\n\n  public static fromJSDelivr<T>(listing: JSDelivrMeta): FileIndex<T> {\n    const idx = new FileIndex<T>();\n\n    listing.files.forEach((file) => {\n      const inode = new FileInode<Stats>(new Stats(FileType.FILE, file.size));\n      idx.addPathFast(file.name, inode);\n    });\n\n    return idx;\n  }\n\n  // Maps directory paths to directory inodes, which contain files.\n  private _index: {[path: string]: DirInode<T> };\n\n  /**\n   * Constructs a new FileIndex.\n   */\n  constructor() {\n    // _index is a single-level key,value store that maps *directory* paths to\n    // DirInodes. File information is only contained in DirInodes themselves.\n    this._index = {};\n    // Create the root directory.\n    this.addPath('/', new DirInode());\n  }\n\n  /**\n   * Runs the given function over all files in the index.\n   */\n  public fileIterator<T>(cb: (file: T | null, path?: string) => void): void {\n    for (const path in this._index) {\n      if (this._index.hasOwnProperty(path)) {\n        const dir = this._index[path];\n        const files = dir.getListing();\n        for (const file of files) {\n          const item = dir.getItem(file);\n          if (isFileInode<T>(item)) {\n            cb(item.getData(), path + '/' + file);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Adds the given absolute path to the index if it is not already in the index.\n   * Creates any needed parent directories.\n   * @param path The path to add to the index.\n   * @param inode The inode for the\n   *   path to add.\n   * @return 'True' if it was added or already exists, 'false' if there\n   *   was an issue adding it (e.g. item in path is a file, item exists but is\n   *   different).\n   * @todo If adding fails and implicitly creates directories, we do not clean up\n   *   the new empty directories.\n   */\n  public addPath(path: string, inode: Inode): boolean {\n    if (!inode) {\n      throw new Error('Inode must be specified');\n    }\n    if (path[0] !== '/') {\n      throw new Error('Path must be absolute, got: ' + path);\n    }\n\n    // Check if it already exists.\n    if (this._index.hasOwnProperty(path)) {\n      return this._index[path] === inode;\n    }\n\n    const splitPath = this._split_path(path);\n    const dirpath = splitPath[0];\n    const itemname = splitPath[1];\n    // Try to add to its parent directory first.\n    let parent = this._index[dirpath];\n    if (parent === undefined && path !== '/') {\n      // Create parent.\n      parent = new DirInode<T>();\n      if (!this.addPath(dirpath, parent)) {\n        return false;\n      }\n    }\n    // Add myself to my parent.\n    if (path !== '/') {\n      if (!parent.addItem(itemname, inode)) {\n        return false;\n      }\n    }\n    // If I'm a directory, add myself to the index.\n    if (isDirInode<T>(inode)) {\n      this._index[path] = inode;\n    }\n    return true;\n  }\n\n  /**\n   * Adds the given absolute path to the index if it is not already in the index.\n   * The path is added without special treatment (no joining of adjacent separators, etc).\n   * Creates any needed parent directories.\n   * @param path The path to add to the index.\n   * @param inode The inode for the\n   *   path to add.\n   * @return 'True' if it was added or already exists, 'false' if there\n   *   was an issue adding it (e.g. item in path is a file, item exists but is\n   *   different).\n   * @todo If adding fails and implicitly creates directories, we do not clean up\n   *   the new empty directories.\n   */\n  public addPathFast(path: string, inode: Inode): boolean {\n    const itemNameMark = path.lastIndexOf('/');\n    const parentPath = itemNameMark === 0 ? \"/\" : path.substring(0, itemNameMark);\n    const itemName = path.substring(itemNameMark + 1);\n\n    // Try to add to its parent directory first.\n    let parent = this._index[parentPath];\n    if (parent === undefined) {\n      // Create parent.\n      parent = new DirInode<T>();\n      this.addPathFast(parentPath, parent);\n    }\n\n    if (!parent.addItem(itemName, inode)) {\n      return false;\n    }\n\n    // If adding a directory, add to the index as well.\n    if (inode.isDir()) {\n      this._index[path] = <DirInode<T>> inode;\n    }\n    return true;\n  }\n\n  /**\n   * Removes the given path. Can be a file or a directory.\n   * @return The removed item,\n   *   or null if it did not exist.\n   */\n  public removePath(path: string): Inode | null {\n    const splitPath = this._split_path(path);\n    const dirpath = splitPath[0];\n    const itemname = splitPath[1];\n\n    // Try to remove it from its parent directory first.\n    const parent = this._index[dirpath];\n    if (parent === undefined) {\n      return null;\n    }\n    // Remove myself from my parent.\n    const inode = parent.remItem(itemname);\n    if (inode === null) {\n      return null;\n    }\n    // If I'm a directory, remove myself from the index, and remove my children.\n    if (isDirInode(inode)) {\n      const children = inode.getListing();\n      for (const child of children) {\n        this.removePath(path + '/' + child);\n      }\n\n      // Remove the directory from the index, unless it's the root.\n      if (path !== '/') {\n        delete this._index[path];\n      }\n    }\n    return inode;\n  }\n\n  /**\n   * Retrieves the directory listing of the given path.\n   * @return An array of files in the given path, or 'null' if it does not exist.\n   */\n  public ls(path: string): string[] | null {\n    const item = this._index[path];\n    if (item === undefined) {\n      return null;\n    }\n    return item.getListing();\n  }\n\n  /**\n   * Returns the inode of the given item.\n   * @return Returns null if the item does not exist.\n   */\n  public getInode(path: string): Inode | null {\n    const splitPath = this._split_path(path);\n    const dirpath = splitPath[0];\n    const itemname = splitPath[1];\n    // Retrieve from its parent directory.\n    const parent = this._index[dirpath];\n    if (parent === undefined) {\n      return null;\n    }\n    // Root case\n    if (dirpath === path) {\n      return parent;\n    }\n    return parent.getItem(itemname);\n  }\n\n  /**\n   * Split into a (directory path, item name) pair\n   */\n  private _split_path(p: string): string[] {\n    const dirpath = path.dirname(p);\n    const itemname = p.substr(dirpath.length + (dirpath === \"/\" ? 0 : 1));\n    return [dirpath, itemname];\n  }\n}\n\n/**\n * Generic interface for file/directory inodes.\n * Note that Stats objects are what we use for file inodes.\n */\nexport interface Inode {\n  // Is this an inode for a file?\n  isFile(): boolean;\n  // Is this an inode for a directory?\n  isDir(): boolean;\n}\n\n/**\n * Inode for a file. Stores an arbitrary (filesystem-specific) data payload.\n */\nexport class FileInode<T> implements Inode {\n  constructor(private data: T) { }\n  public isFile(): boolean { return true; }\n  public isDir(): boolean { return false; }\n  public getData(): T { return this.data; }\n  public setData(data: T): void { this.data = data; }\n}\n\n/**\n * Inode for a directory. Currently only contains the directory listing.\n */\nexport class DirInode<T> implements Inode {\n  private _ls: {[path: string]: Inode} = {};\n  /**\n   * Constructs an inode for a directory.\n   */\n  constructor(private data: T | null = null) {}\n  public isFile(): boolean {\n    return false;\n  }\n\n  public isDir(): boolean {\n    return true;\n  }\n\n  public getData(): T | null { return this.data; }\n\n  /**\n   * Return a Stats object for this inode.\n   * @todo Should probably remove this at some point. This isn't the\n   *       responsibility of the FileIndex.\n   */\n  public getStats(): Stats {\n    return new Stats(FileType.DIRECTORY, 4096, 0x16D);\n  }\n\n  /**\n   * Returns the directory listing for this directory. Paths in the directory are\n   * relative to the directory's path.\n   * @return The directory listing for this directory.\n   */\n  public getListing(): string[] {\n    return Object.keys(this._ls);\n  }\n\n  /**\n   * Returns the inode for the indicated item, or null if it does not exist.\n   * @param p Name of item in this directory.\n   */\n  public getItem(p: string): Inode | null {\n    const item = this._ls[p];\n\n    return item && this._ls.hasOwnProperty(p) ? item : null;\n  }\n\n  /**\n   * Add the given item to the directory listing. Note that the given inode is\n   * not copied, and will be mutated by the DirInode if it is a DirInode.\n   * @param p Item name to add to the directory listing.\n   * @param inode The inode for the\n   *   item to add to the directory inode.\n   * @return True if it was added, false if it already existed.\n   */\n  public addItem(p: string, inode: Inode): boolean {\n    if (p in this._ls) {\n      return false;\n    }\n    this._ls[p] = inode;\n    return true;\n  }\n\n  /**\n   * Removes the given item from the directory listing.\n   * @param p Name of item to remove from the directory listing.\n   * @return Returns the item\n   *   removed, or null if the item did not exist.\n   */\n  public remItem(p: string): Inode | null {\n    const item = this._ls[p];\n    if (item === undefined) {\n      return null;\n    }\n    delete this._ls[p];\n    return item;\n  }\n}\n\n/**\n * @hidden\n */\nexport function isFileInode<T>(inode: Inode | null): inode is FileInode<T> {\n  return !!inode && inode.isFile();\n}\n\n/**\n * @hidden\n */\nexport function isDirInode<T>(inode: Inode | null): inode is DirInode<T> {\n  return !!inode && inode.isDir();\n}\n"]}