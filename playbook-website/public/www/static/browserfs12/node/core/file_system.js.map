{"version":3,"file":"file_system.js","sourceRoot":"","sources":["../../../src/core/file_system.ts"],"names":[],"mappings":"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","sourcesContent":["import {ApiError, ErrorCode} from './api_error';\nimport Stats from './node_fs_stats';\nimport {File} from './file';\nimport {FileFlag, ActionType} from './file_flag';\nimport * as path from 'path';\nimport {fail} from './util';\n\nexport type BFSOneArgCallback = (e?: ApiError | null) => any;\nexport type BFSCallback<T> = (e: ApiError | null | undefined, rv?: T) => any;\nexport type BFSThreeArgCallback<T, U> =\n  (e: ApiError | null | undefined, arg1?: T, arg2?: U) => any;\n\n/**\n * Interface for a filesystem. **All** BrowserFS FileSystems should implement\n * this interface.\n *\n * Below, we denote each API method as **Core**, **Supplemental**, or\n * **Optional**.\n *\n * ### Core Methods\n *\n * **Core** API methods *need* to be implemented for basic read/write\n * functionality.\n *\n * Note that read-only FileSystems can choose to not implement core methods\n * that mutate files or metadata. The default implementation will pass a\n * NOT_SUPPORTED error to the callback.\n *\n * ### Supplemental Methods\n *\n * **Supplemental** API methods do not need to be implemented by a filesystem.\n * The default implementation implements all of the supplemental API methods in\n * terms of the **core** API methods.\n *\n * Note that a file system may choose to implement supplemental methods for\n * efficiency reasons.\n *\n * The code for some supplemental methods was adapted directly from NodeJS's\n * fs.js source code.\n *\n * ### Optional Methods\n *\n * **Optional** API methods provide functionality that may not be available in\n * all filesystems. For example, all symlink/hardlink-related API methods fall\n * under this category.\n *\n * The default implementation will pass a NOT_SUPPORTED error to the callback.\n *\n * ### Argument Assumptions\n *\n * You can assume the following about arguments passed to each API method:\n *\n * * **Every path is an absolute path.** Meaning, `.`, `..`, and other items\n *   are resolved into an absolute form.\n * * **All arguments are present.** Any optional arguments at the Node API level\n *   have been passed in with their default values.\n * * **The callback will reset the stack depth.** When your filesystem calls the\n *   callback with the requested information, it will use `setImmediate` to\n *   reset the JavaScript stack depth before calling the user-supplied callback.\n */\nexport interface FileSystem {\n  /**\n   * **Optional**: Returns the name of the file system.\n   */\n  getName(): string;\n  /**\n   * **Optional**: Passes the following information to the callback:\n   *\n   * * Total number of bytes available on this file system.\n   * * number of free bytes available on this file system.\n   *\n   * @todo This info is not available through the Node API. Perhaps we could do a\n   *   polyfill of diskspace.js, or add a new Node API function.\n   * @param path The path to the location that is being queried. Only\n   *   useful for filesystems that support mount points.\n   */\n  diskSpace(p: string, cb: (total: number, free: number) => any): void;\n  /**\n   * **Core**: Is this filesystem read-only?\n   * @return True if this FileSystem is inherently read-only.\n   */\n  isReadOnly(): boolean;\n  /**\n   * **Core**: Does the filesystem support optional symlink/hardlink-related\n   *   commands?\n   * @return True if the FileSystem supports the optional\n   *   symlink/hardlink-related commands.\n   */\n  supportsLinks(): boolean;\n  /**\n   * **Core**: Does the filesystem support optional property-related commands?\n   * @return True if the FileSystem supports the optional\n   *   property-related commands (permissions, utimes, etc).\n   */\n  supportsProps(): boolean;\n  /**\n   * **Core**: Does the filesystem support the optional synchronous interface?\n   * @return True if the FileSystem supports synchronous operations.\n   */\n  supportsSynch(): boolean;\n  // **CORE API METHODS**\n  // File or directory operations\n  /**\n   * **Core**: Asynchronous rename. No arguments other than a possible exception\n   * are given to the completion callback.\n   */\n  rename(oldPath: string, newPath: string, cb: BFSOneArgCallback): void;\n  /**\n   * **Core**: Synchronous rename.\n   */\n  renameSync(oldPath: string, newPath: string): void;\n  /**\n   * **Core**: Asynchronous `stat` or `lstat`.\n   * @param isLstat True if this is `lstat`, false if this is regular\n   *   `stat`.\n   */\n  stat(p: string, isLstat: boolean | null, cb: BFSCallback<Stats>): void;\n  /**\n   * **Core**: Synchronous `stat` or `lstat`.\n   * @param isLstat True if this is `lstat`, false if this is regular\n   *   `stat`.\n   */\n  statSync(p: string, isLstat: boolean | null): Stats;\n  // File operations\n  /**\n   * **Core**: Asynchronous file open.\n   * @see http://www.manpagez.com/man/2/open/\n   * @param flags Handles the complexity of the various file\n   *   modes. See its API for more details.\n   * @param mode Mode to use to open the file. Can be ignored if the\n   *   filesystem doesn't support permissions.\n   */\n  open(p: string, flag: FileFlag, mode: number, cb: BFSCallback<File>): void;\n  /**\n   * **Core**: Synchronous file open.\n   * @see http://www.manpagez.com/man/2/open/\n   * @param flags Handles the complexity of the various file\n   *   modes. See its API for more details.\n   * @param mode Mode to use to open the file. Can be ignored if the\n   *   filesystem doesn't support permissions.\n   */\n  openSync(p: string, flag: FileFlag, mode: number): File;\n  /**\n   * **Core**: Asynchronous `unlink`.\n   */\n  unlink(p: string, cb: BFSOneArgCallback): void;\n  /**\n   * **Core**: Synchronous `unlink`.\n   */\n  unlinkSync(p: string): void;\n  // Directory operations\n  /**\n   * **Core**: Asynchronous `rmdir`.\n   */\n  rmdir(p: string, cb: BFSOneArgCallback): void;\n  /**\n   * **Core**: Synchronous `rmdir`.\n   */\n  rmdirSync(p: string): void;\n  /**\n   * **Core**: Asynchronous `mkdir`.\n   * @param mode Mode to make the directory using. Can be ignored if\n   *   the filesystem doesn't support permissions.\n   */\n  mkdir(p: string, mode: number, cb: BFSOneArgCallback): void;\n  /**\n   * **Core**: Synchronous `mkdir`.\n   * @param mode Mode to make the directory using. Can be ignored if\n   *   the filesystem doesn't support permissions.\n   */\n  mkdirSync(p: string, mode: number): void;\n  /**\n   * **Core**: Asynchronous `readdir`. Reads the contents of a directory.\n   *\n   * The callback gets two arguments `(err, files)` where `files` is an array of\n   * the names of the files in the directory excluding `'.'` and `'..'`.\n   */\n  readdir(p: string, cb: BFSCallback<string[]>): void;\n  /**\n   * **Core**: Synchronous `readdir`. Reads the contents of a directory.\n   */\n  readdirSync(p: string): string[];\n  // **SUPPLEMENTAL INTERFACE METHODS**\n  // File or directory operations\n  /**\n   * **Supplemental**: Test whether or not the given path exists by checking with\n   * the file system. Then call the callback argument with either true or false.\n   */\n  exists(p: string, cb: (exists: boolean) => void): void;\n  /**\n   * **Supplemental**: Test whether or not the given path exists by checking with\n   * the file system.\n   */\n  existsSync(p: string): boolean;\n  /**\n   * **Supplemental**: Asynchronous `realpath`. The callback gets two arguments\n   * `(err, resolvedPath)`.\n   *\n   * Note that the Node API will resolve `path` to an absolute path.\n   * @param cache An object literal of mapped paths that can be used to\n   *   force a specific path resolution or avoid additional `fs.stat` calls for\n   *   known real paths. If not supplied by the user, it'll be an empty object.\n   */\n  realpath(p: string, cache: {[path: string]: string}, cb: BFSCallback<string>): void;\n  /**\n   * **Supplemental**: Synchronous `realpath`.\n   *\n   * Note that the Node API will resolve `path` to an absolute path.\n   * @param cache An object literal of mapped paths that can be used to\n   *   force a specific path resolution or avoid additional `fs.stat` calls for\n   *   known real paths. If not supplied by the user, it'll be an empty object.\n   */\n  realpathSync(p: string, cache: {[path: string]: string}): string;\n  // File operations\n  /**\n   * **Supplemental**: Asynchronous `truncate`.\n   */\n  truncate(p: string, len: number, cb: BFSOneArgCallback): void;\n  /**\n   * **Supplemental**: Synchronous `truncate`.\n   */\n  truncateSync(p: string, len: number): void;\n  /**\n   * **Supplemental**: Asynchronously reads the entire contents of a file.\n   * @param encoding If non-null, the file's contents should be decoded\n   *   into a string using that encoding. Otherwise, if encoding is null, fetch\n   *   the file's contents as a Buffer.\n   * @param cb If no encoding is specified, then the raw buffer is returned.\n   */\n  readFile(fname: string, encoding: string | null, flag: FileFlag, cb: BFSCallback<string | Buffer>): void;\n  /**\n   * **Supplemental**: Synchronously reads the entire contents of a file.\n   * @param encoding If non-null, the file's contents should be decoded\n   *   into a string using that encoding. Otherwise, if encoding is null, fetch\n   *   the file's contents as a Buffer.\n   */\n  readFileSync(fname: string, encoding: string | null, flag: FileFlag): any;\n  /**\n   * **Supplemental**: Asynchronously writes data to a file, replacing the file\n   * if it already exists.\n   *\n   * The encoding option is ignored if data is a buffer.\n   */\n  writeFile(fname: string, data: any, encoding: string | null, flag: FileFlag, mode: number, cb: BFSOneArgCallback): void;\n  /**\n   * **Supplemental**: Synchronously writes data to a file, replacing the file\n   * if it already exists.\n   *\n   * The encoding option is ignored if data is a buffer.\n   */\n  writeFileSync(fname: string, data: string | Buffer, encoding: string | null, flag: FileFlag, mode: number): void;\n  /**\n   * **Supplemental**: Asynchronously append data to a file, creating the file if\n   * it not yet exists.\n   */\n  appendFile(fname: string, data: string | Buffer, encoding: string | null, flag: FileFlag, mode: number, cb: BFSOneArgCallback): void;\n  /**\n   * **Supplemental**: Synchronously append data to a file, creating the file if\n   * it not yet exists.\n   */\n  appendFileSync(fname: string, data: string | Buffer, encoding: string | null, flag: FileFlag, mode: number): void;\n  // **OPTIONAL INTERFACE METHODS**\n  // Property operations\n  // This isn't always possible on some filesystem types (e.g. Dropbox).\n  /**\n   * **Optional**: Asynchronous `chmod` or `lchmod`.\n   * @param isLchmod `True` if `lchmod`, false if `chmod`. Has no\n   *   bearing on result if links aren't supported.\n   */\n  chmod(p: string, isLchmod: boolean, mode: number, cb: BFSOneArgCallback): void;\n  /**\n   * **Optional**: Synchronous `chmod` or `lchmod`.\n   * @param isLchmod `True` if `lchmod`, false if `chmod`. Has no\n   *   bearing on result if links aren't supported.\n   */\n  chmodSync(p: string, isLchmod: boolean, mode: number): void;\n  /**\n   * **Optional**: Asynchronous `chown` or `lchown`.\n   * @param isLchown `True` if `lchown`, false if `chown`. Has no\n   *   bearing on result if links aren't supported.\n   */\n  chown(p: string, isLchown: boolean, uid: number, gid: number, cb: BFSOneArgCallback): void;\n  /**\n   * **Optional**: Synchronous `chown` or `lchown`.\n   * @param isLchown `True` if `lchown`, false if `chown`. Has no\n   *   bearing on result if links aren't supported.\n   */\n  chownSync(p: string, isLchown: boolean, uid: number, gid: number): void;\n  /**\n   * **Optional**: Change file timestamps of the file referenced by the supplied\n   * path.\n   */\n  utimes(p: string, atime: Date, mtime: Date, cb: BFSOneArgCallback): void;\n  /**\n   * **Optional**: Change file timestamps of the file referenced by the supplied\n   * path.\n   */\n  utimesSync(p: string, atime: Date, mtime: Date): void;\n  // Symlink operations\n  // Symlinks aren't always supported.\n  /**\n   * **Optional**: Asynchronous `link`.\n   */\n  link(srcpath: string, dstpath: string, cb: BFSOneArgCallback): void;\n  /**\n   * **Optional**: Synchronous `link`.\n   */\n  linkSync(srcpath: string, dstpath: string): void;\n  /**\n   * **Optional**: Asynchronous `symlink`.\n   * @param type can be either `'dir'` or `'file'`\n   */\n  symlink(srcpath: string, dstpath: string, type: string, cb: BFSOneArgCallback): void;\n  /**\n   * **Optional**: Synchronous `symlink`.\n   * @param type can be either `'dir'` or `'file'`\n   */\n  symlinkSync(srcpath: string, dstpath: string, type: string): void;\n  /**\n   * **Optional**: Asynchronous readlink.\n   */\n  readlink(p: string, cb: BFSCallback<string>): void;\n  /**\n   * **Optional**: Synchronous readlink.\n   */\n  readlinkSync(p: string): string;\n}\n\n/**\n * Describes a file system option.\n */\nexport interface FileSystemOption<T> {\n  // The basic JavaScript type(s) for this option.\n  type: string | string[];\n  // Whether or not the option is optional (e.g., can be set to null or undefined).\n  // Defaults to `false`.\n  optional?: boolean;\n  // Description of the option. Used in error messages and documentation.\n  description: string;\n  // A custom validation function to check if the option is valid.\n  // Calls the callback with an error object on an error.\n  // (Can call callback synchronously.)\n  // Defaults to `(opt, cb) => cb()`.\n  validator?(opt: T, cb: BFSOneArgCallback): void;\n}\n\n/**\n * Describes all of the options available in a file system.\n */\nexport interface FileSystemOptions {\n  [name: string]: FileSystemOption<any>;\n}\n\n/**\n * Contains typings for static functions on the file system constructor.\n */\nexport interface FileSystemConstructor {\n  /**\n   * **Core**: Name to identify this particular file system.\n   */\n  Name: string;\n  /**\n   * **Core**: Describes all of the options available for this file system.\n   */\n  Options: FileSystemOptions;\n  /**\n   * **Core**: Creates a file system of this given type with the given\n   * options.\n   */\n  Create(options: object, cb: BFSCallback<FileSystem>): void;\n  /**\n   * **Core**: Returns 'true' if this filesystem is available in the current\n   * environment. For example, a `localStorage`-backed filesystem will return\n   * 'false' if the browser does not support that API.\n   *\n   * Defaults to 'false', as the FileSystem base class isn't usable alone.\n   */\n  isAvailable(): boolean;\n}\n\n/**\n * Basic filesystem class. Most filesystems should extend this class, as it\n * provides default implementations for a handful of methods.\n */\nexport class BaseFileSystem {\n  public supportsLinks(): boolean {\n    return false;\n  }\n  public diskSpace(p: string, cb: (total: number, free: number) => any): void {\n    cb(0, 0);\n  }\n  /**\n   * Opens the file at path p with the given flag. The file must exist.\n   * @param p The path to open.\n   * @param flag The flag to use when opening the file.\n   */\n  public openFile(p: string, flag: FileFlag, cb: BFSCallback<File>): void {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n  /**\n   * Create the file at path p with the given mode. Then, open it with the given\n   * flag.\n   */\n  public createFile(p: string, flag: FileFlag, mode: number, cb: BFSCallback<File>): void {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n  public open(p: string, flag: FileFlag, mode: number, cb: BFSCallback<File>): void {\n    const mustBeFile = (e: ApiError, stats?: Stats): void => {\n      if (e) {\n        // File does not exist.\n        switch (flag.pathNotExistsAction()) {\n          case ActionType.CREATE_FILE:\n            // Ensure parent exists.\n            return this.stat(path.dirname(p), false, (e: ApiError, parentStats?: Stats) => {\n              if (e) {\n                cb(e);\n              } else if (parentStats && !parentStats.isDirectory()) {\n                cb(ApiError.ENOTDIR(path.dirname(p)));\n              } else {\n                this.createFile(p, flag, mode, cb);\n              }\n            });\n          case ActionType.THROW_EXCEPTION:\n            return cb(ApiError.ENOENT(p));\n          default:\n            return cb(new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.'));\n        }\n      } else {\n        // File exists.\n        if (stats && stats.isDirectory()) {\n          return cb(ApiError.EISDIR(p));\n        }\n        switch (flag.pathExistsAction()) {\n          case ActionType.THROW_EXCEPTION:\n            return cb(ApiError.EEXIST(p));\n          case ActionType.TRUNCATE_FILE:\n            // NOTE: In a previous implementation, we deleted the file and\n            // re-created it. However, this created a race condition if another\n            // asynchronous request was trying to read the file, as the file\n            // would not exist for a small period of time.\n            return this.openFile(p, flag, (e: ApiError, fd?: File): void => {\n              if (e) {\n                cb(e);\n              } else if (fd) {\n                fd.truncate(0, () => {\n                  fd.sync(() => {\n                    cb(null, fd);\n                  });\n                });\n              } else {\n                fail();\n              }\n            });\n          case ActionType.NOP:\n            return this.openFile(p, flag, cb);\n          default:\n            return cb(new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.'));\n        }\n      }\n    };\n    this.stat(p, false, mustBeFile);\n  }\n  public rename(oldPath: string, newPath: string, cb: BFSOneArgCallback): void {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n  }\n  public renameSync(oldPath: string, newPath: string): void {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n  public stat(p: string, isLstat: boolean | null, cb: BFSCallback<Stats>): void {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n  }\n  public statSync(p: string, isLstat: boolean | null): Stats {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n  /**\n   * Opens the file at path p with the given flag. The file must exist.\n   * @param p The path to open.\n   * @param flag The flag to use when opening the file.\n   * @return A File object corresponding to the opened file.\n   */\n  public openFileSync(p: string, flag: FileFlag, mode: number): File {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n  /**\n   * Create the file at path p with the given mode. Then, open it with the given\n   * flag.\n   */\n  public createFileSync(p: string, flag: FileFlag, mode: number): File {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n  public openSync(p: string, flag: FileFlag, mode: number): File {\n    // Check if the path exists, and is a file.\n    let stats: Stats;\n    try {\n      stats = this.statSync(p, false);\n    } catch (e) {\n      // File does not exist.\n      switch (flag.pathNotExistsAction()) {\n        case ActionType.CREATE_FILE:\n          // Ensure parent exists.\n          const parentStats = this.statSync(path.dirname(p), false);\n          if (!parentStats.isDirectory()) {\n            throw ApiError.ENOTDIR(path.dirname(p));\n          }\n          return this.createFileSync(p, flag, mode);\n        case ActionType.THROW_EXCEPTION:\n          throw ApiError.ENOENT(p);\n        default:\n          throw new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.');\n      }\n    }\n\n    // File exists.\n    if (stats.isDirectory()) {\n      throw ApiError.EISDIR(p);\n    }\n    switch (flag.pathExistsAction()) {\n      case ActionType.THROW_EXCEPTION:\n        throw ApiError.EEXIST(p);\n      case ActionType.TRUNCATE_FILE:\n        // Delete file.\n        this.unlinkSync(p);\n        // Create file. Use the same mode as the old file.\n        // Node itself modifies the ctime when this occurs, so this action\n        // will preserve that behavior if the underlying file system\n        // supports those properties.\n        return this.createFileSync(p, flag, stats.mode);\n      case ActionType.NOP:\n        return this.openFileSync(p, flag, mode);\n      default:\n        throw new ApiError(ErrorCode.EINVAL, 'Invalid FileFlag object.');\n    }\n  }\n  public unlink(p: string, cb: BFSOneArgCallback): void {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n  }\n  public unlinkSync(p: string): void {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n  public rmdir(p: string, cb: BFSOneArgCallback): void {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n  }\n  public rmdirSync(p: string): void {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n  public mkdir(p: string, mode: number, cb: BFSOneArgCallback): void {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n  }\n  public mkdirSync(p: string, mode: number): void {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n  public readdir(p: string, cb: BFSCallback<string[]>): void {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n  }\n  public readdirSync(p: string): string[] {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n  public exists(p: string, cb: (exists: boolean) => void): void {\n    this.stat(p, null, function(err) {\n      cb(!err);\n    });\n  }\n  public existsSync(p: string): boolean {\n    try {\n      this.statSync(p, true);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  public realpath(p: string, cache: {[path: string]: string}, cb: BFSCallback<string>): void {\n    if (this.supportsLinks()) {\n      // The path could contain symlinks. Split up the path,\n      // resolve any symlinks, return the resolved string.\n      const splitPath = p.split(path.sep);\n      // TODO: Simpler to just pass through file, find sep and such.\n      for (let i = 0; i < splitPath.length; i++) {\n        const addPaths = splitPath.slice(0, i + 1);\n        splitPath[i] = path.join.apply(null, addPaths);\n      }\n    } else {\n      // No symlinks. We just need to verify that it exists.\n      this.exists(p, function(doesExist) {\n        if (doesExist) {\n          cb(null, p);\n        } else {\n          cb(ApiError.ENOENT(p));\n        }\n      });\n    }\n  }\n  public realpathSync(p: string, cache: {[path: string]: string}): string {\n    if (this.supportsLinks()) {\n      // The path could contain symlinks. Split up the path,\n      // resolve any symlinks, return the resolved string.\n      const splitPath = p.split(path.sep);\n      // TODO: Simpler to just pass through file, find sep and such.\n      for (let i = 0; i < splitPath.length; i++) {\n        const addPaths = splitPath.slice(0, i + 1);\n        splitPath[i] = path.join.apply(path, addPaths);\n      }\n      return splitPath.join(path.sep);\n    } else {\n      // No symlinks. We just need to verify that it exists.\n      if (this.existsSync(p)) {\n        return p;\n      } else {\n        throw ApiError.ENOENT(p);\n      }\n    }\n  }\n  public truncate(p: string, len: number, cb: BFSOneArgCallback): void {\n    this.open(p, FileFlag.getFileFlag('r+'), 0x1a4, (function(er: ApiError, fd?: File) {\n      if (er) {\n        return cb(er);\n      }\n      fd!.truncate(len, (function(er: any) {\n        fd!.close((function(er2: any) {\n          cb(er || er2);\n        }));\n      }));\n    }));\n  }\n  public truncateSync(p: string, len: number): void {\n    const fd = this.openSync(p, FileFlag.getFileFlag('r+'), 0x1a4);\n    // Need to safely close FD, regardless of whether or not truncate succeeds.\n    try {\n      fd.truncateSync(len);\n    } catch (e) {\n      throw e;\n    } finally {\n      fd.closeSync();\n    }\n  }\n  public readFile(fname: string, encoding: string | null, flag: FileFlag, cb: BFSCallback<string | Buffer>): void {\n    // Wrap cb in file closing code.\n    const oldCb = cb;\n    // Get file.\n    this.open(fname, flag, 0x1a4, (err, fd) => {\n      if (err) {\n        return cb(err);\n      }\n      cb = function(err?: ApiError | null, arg?: string | Buffer) {\n        fd!.close(function(err2: any) {\n          if (!err) {\n            err = err2;\n          }\n          return oldCb(err, arg);\n        });\n      };\n      fd!.stat((err, stat?) => {\n        if (err) {\n          return cb(err);\n        }\n        // Allocate buffer.\n        const buf = Buffer.alloc(stat!.size);\n        fd!.read(buf, 0, stat!.size, 0, (err?: ApiError | null) => {\n          if (err) {\n            return cb(err);\n          } else if (encoding === null) {\n            return cb(err, buf);\n          }\n          try {\n            cb(null, buf.toString(encoding));\n          } catch (e) {\n            cb(e);\n          }\n        });\n      });\n    });\n  }\n  public readFileSync(fname: string, encoding: string | null, flag: FileFlag): any {\n    // Get file.\n    const fd = this.openSync(fname, flag, 0x1a4);\n    try {\n      const stat = fd.statSync();\n      // Allocate buffer.\n      const buf = Buffer.alloc(stat.size);\n      fd.readSync(buf, 0, stat.size, 0);\n      fd.closeSync();\n      if (encoding === null) {\n        return buf;\n      }\n      return buf.toString(encoding);\n    } finally {\n      fd.closeSync();\n    }\n  }\n  public writeFile(fname: string, data: any, encoding: string | null, flag: FileFlag, mode: number, cb: BFSOneArgCallback): void {\n    // Wrap cb in file closing code.\n    const oldCb = cb;\n    // Get file.\n    this.open(fname, flag, 0x1a4, function(err: ApiError, fd?: File) {\n      if (err) {\n        return cb(err);\n      }\n      cb = function(err: ApiError) {\n        fd!.close(function(err2: any) {\n          oldCb(err ? err : err2);\n        });\n      };\n\n      try {\n        if (typeof data === 'string') {\n          data = Buffer.from(data, encoding!);\n        }\n      } catch (e) {\n        return cb(e);\n      }\n      // Write into file.\n      fd!.write(data, 0, data.length, 0, cb);\n    });\n  }\n  public writeFileSync(fname: string, data: any, encoding: string | null, flag: FileFlag, mode: number): void {\n    // Get file.\n    const fd = this.openSync(fname, flag, mode);\n    try {\n      if (typeof data === 'string') {\n        data = Buffer.from(data, encoding!);\n      }\n      // Write into file.\n      fd.writeSync(data, 0, data.length, 0);\n    } finally {\n      fd.closeSync();\n    }\n  }\n  public appendFile(fname: string, data: any, encoding: string | null, flag: FileFlag, mode: number, cb: BFSOneArgCallback): void {\n    // Wrap cb in file closing code.\n    const oldCb = cb;\n    this.open(fname, flag, mode, function(err: ApiError, fd?: File) {\n      if (err) {\n        return cb(err);\n      }\n      cb = function(err: ApiError) {\n        fd!.close(function(err2: any) {\n          oldCb(err ? err : err2);\n        });\n      };\n      if (typeof data === 'string') {\n        data = Buffer.from(data, encoding!);\n      }\n      fd!.write(data, 0, data.length, null, cb);\n    });\n  }\n  public appendFileSync(fname: string, data: any, encoding: string | null, flag: FileFlag, mode: number): void {\n    const fd = this.openSync(fname, flag, mode);\n    try {\n      if (typeof data === 'string') {\n        data = Buffer.from(data, encoding!);\n      }\n      fd.writeSync(data, 0, data.length, null);\n    } finally {\n      fd.closeSync();\n    }\n  }\n  public chmod(p: string, isLchmod: boolean, mode: number, cb: BFSOneArgCallback): void {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n  }\n  public chmodSync(p: string, isLchmod: boolean, mode: number) {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n  public chown(p: string, isLchown: boolean, uid: number, gid: number, cb: BFSOneArgCallback): void {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n  }\n  public chownSync(p: string, isLchown: boolean, uid: number, gid: number): void {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n  public utimes(p: string, atime: Date, mtime: Date, cb: BFSOneArgCallback): void {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n  }\n  public utimesSync(p: string, atime: Date, mtime: Date): void {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n  public link(srcpath: string, dstpath: string, cb: BFSOneArgCallback): void {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n  }\n  public linkSync(srcpath: string, dstpath: string): void {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n  public symlink(srcpath: string, dstpath: string, type: string, cb: BFSOneArgCallback): void {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n  }\n  public symlinkSync(srcpath: string, dstpath: string, type: string): void {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n  public readlink(p: string, cb: BFSOneArgCallback): void {\n    cb(new ApiError(ErrorCode.ENOTSUP));\n  }\n  public readlinkSync(p: string): string {\n    throw new ApiError(ErrorCode.ENOTSUP);\n  }\n}\n\n/**\n * Implements the asynchronous API in terms of the synchronous API.\n * @class SynchronousFileSystem\n */\nexport class SynchronousFileSystem extends BaseFileSystem {\n  public supportsSynch(): boolean {\n    return true;\n  }\n\n  public rename(oldPath: string, newPath: string, cb: BFSOneArgCallback): void {\n    try {\n      this.renameSync(oldPath, newPath);\n      cb();\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  public stat(p: string, isLstat: boolean | null, cb: BFSCallback<Stats>): void {\n    try {\n      cb(null, this.statSync(p, isLstat));\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  public open(p: string, flags: FileFlag, mode: number, cb: BFSCallback<File>): void {\n    try {\n      cb(null, this.openSync(p, flags, mode));\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  public unlink(p: string, cb: BFSOneArgCallback): void {\n    try {\n      this.unlinkSync(p);\n      cb();\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  public rmdir(p: string, cb: BFSOneArgCallback): void {\n    try {\n      this.rmdirSync(p);\n      cb();\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  public mkdir(p: string, mode: number, cb: BFSOneArgCallback): void {\n    try {\n      this.mkdirSync(p, mode);\n      cb();\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  public readdir(p: string, cb: BFSCallback<string[]>): void {\n    try {\n      cb(null, this.readdirSync(p));\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  public chmod(p: string, isLchmod: boolean, mode: number, cb: BFSOneArgCallback): void {\n    try {\n      this.chmodSync(p, isLchmod, mode);\n      cb();\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  public chown(p: string, isLchown: boolean, uid: number, gid: number, cb: BFSOneArgCallback): void {\n    try {\n      this.chownSync(p, isLchown, uid, gid);\n      cb();\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  public utimes(p: string, atime: Date, mtime: Date, cb: BFSOneArgCallback): void {\n    try {\n      this.utimesSync(p, atime, mtime);\n      cb();\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  public link(srcpath: string, dstpath: string, cb: BFSOneArgCallback): void {\n    try {\n      this.linkSync(srcpath, dstpath);\n      cb();\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  public symlink(srcpath: string, dstpath: string, type: string, cb: BFSOneArgCallback): void {\n    try {\n      this.symlinkSync(srcpath, dstpath, type);\n      cb();\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  public readlink(p: string, cb: BFSCallback<string>): void {\n    try {\n      cb(null, this.readlinkSync(p));\n    } catch (e) {\n      cb(e);\n    }\n  }\n}\n"]}