{"version":3,"file":"HTTPRequest.js","sourceRoot":"","sources":["../../../src/backend/HTTPRequest.ts"],"names":[],"mappings":"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","sourcesContent":["import {BaseFileSystem, FileSystem, BFSCallback, FileSystemOptions} from '../core/file_system';\nimport {ApiError, ErrorCode} from '../core/api_error';\nimport {FileFlag, ActionType} from '../core/file_flag';\nimport {copyingSlice} from '../core/util';\nimport {File} from '../core/file';\nimport Stats from '../core/node_fs_stats';\nimport {NoSyncFile} from '../generic/preload_file';\nimport {xhrIsAvailable, asyncDownloadFile, syncDownloadFile, getFileSizeAsync, getFileSizeSync} from '../generic/xhr';\nimport {fetchIsAvailable, fetchFileAsync, fetchFileSizeAsync} from '../generic/fetch';\nimport {FileIndex, isFileInode, isDirInode} from '../generic/file_index';\n\n/**\n * Try to convert the given buffer into a string, and pass it to the callback.\n * Optimization that removes the needed try/catch into a helper function, as\n * this is an uncommon case.\n * @hidden\n */\nfunction tryToString(buff: Buffer, encoding: string, cb: BFSCallback<string>) {\n  try {\n    cb(null, buff.toString(encoding));\n  } catch (e) {\n    cb(e);\n  }\n}\n\n/**\n * Configuration options for a HTTPRequest file system.\n */\nexport interface HTTPRequestOptions {\n  // URL to a file index as a JSON file or the file index object itself, generated with the make_http_index script.\n  // Defaults to `index.json`.\n  index?: string | object;\n  // Used as the URL prefix for fetched files.\n  // Default: Fetch files relative to the index.\n  baseUrl?: string;\n  // Whether to prefer XmlHttpRequest or fetch for async operations if both are available.\n  // Default: false\n  preferXHR?: boolean;\n}\n\ninterface AsyncDownloadFileMethod {\n  (p: string, type: 'buffer', cb: BFSCallback<Buffer>): void;\n  (p: string, type: 'json', cb: BFSCallback<any>): void;\n  (p: string, type: string, cb: BFSCallback<any>): void;\n}\n\ninterface SyncDownloadFileMethod {\n  (p: string, type: 'buffer'): Buffer;\n  (p: string, type: 'json'): any;\n  (p: string, type: string): any;\n}\n\nfunction syncNotAvailableError(): never {\n  throw new ApiError(ErrorCode.ENOTSUP, `Synchronous HTTP download methods are not available in this environment.`);\n}\n\n/**\n * A simple filesystem backed by HTTP downloads. You must create a directory listing using the\n * `make_http_index` tool provided by BrowserFS.\n *\n * If you install BrowserFS globally with `npm i -g browserfs`, you can generate a listing by\n * running `make_http_index` in your terminal in the directory you would like to index:\n *\n * ```\n * make_http_index > index.json\n * ```\n *\n * Listings objects look like the following:\n *\n * ```json\n * {\n *   \"home\": {\n *     \"jvilk\": {\n *       \"someFile.txt\": null,\n *       \"someDir\": {\n *         // Empty directory\n *       }\n *     }\n *   }\n * }\n * ```\n *\n * *This example has the folder `/home/jvilk` with subfile `someFile.txt` and subfolder `someDir`.*\n */\nexport default class HTTPRequest extends BaseFileSystem implements FileSystem {\n  public static readonly Name = \"HTTPRequest\";\n\n  public static readonly Options: FileSystemOptions = {\n    index: {\n      type: [\"string\", \"object\"],\n      optional: true,\n      description: \"URL to a file index as a JSON file or the file index object itself, generated with the make_http_index script. Defaults to `index.json`.\"\n    },\n    baseUrl: {\n      type: \"string\",\n      optional: true,\n      description: \"Used as the URL prefix for fetched files. Default: Fetch files relative to the index.\"\n    },\n    preferXHR: {\n      type: \"boolean\",\n      optional: true,\n      description: \"Whether to prefer XmlHttpRequest or fetch for async operations if both are available. Default: false\"\n    }\n  };\n\n  /**\n   * Construct an HTTPRequest file system backend with the given options.\n   */\n  public static Create(opts: HTTPRequestOptions, cb: BFSCallback<HTTPRequest>): void {\n    if (opts.index === undefined) {\n      opts.index = `index.json`;\n    }\n    if (typeof(opts.index) === \"string\") {\n      asyncDownloadFile(opts.index, \"json\", (e, data?) => {\n        if (e) {\n          cb(e);\n        } else {\n          cb(null, new HTTPRequest(data, opts.baseUrl));\n        }\n      });\n    } else {\n      cb(null, new HTTPRequest(opts.index, opts.baseUrl));\n    }\n  }\n\n  public static isAvailable(): boolean {\n    return xhrIsAvailable || fetchIsAvailable;\n  }\n\n  public readonly prefixUrl: string;\n  private _index: FileIndex<{}>;\n  private _requestFileAsyncInternal: AsyncDownloadFileMethod;\n  private _requestFileSizeAsyncInternal: (p: string, cb: BFSCallback<number>) => void;\n  private _requestFileSyncInternal: SyncDownloadFileMethod;\n  private _requestFileSizeSyncInternal: (p: string) => number;\n\n  private constructor(index: object, prefixUrl: string = '', preferXHR: boolean = false) {\n    super();\n    // prefix_url must end in a directory separator.\n    if (prefixUrl.length > 0 && prefixUrl.charAt(prefixUrl.length - 1) !== '/') {\n      prefixUrl = prefixUrl + '/';\n    }\n    this.prefixUrl = prefixUrl;\n    this._index = FileIndex.fromListing(index);\n\n    if (fetchIsAvailable && (!preferXHR || !xhrIsAvailable)) {\n      this._requestFileAsyncInternal = fetchFileAsync;\n      this._requestFileSizeAsyncInternal = fetchFileSizeAsync;\n    } else {\n      this._requestFileAsyncInternal = asyncDownloadFile;\n      this._requestFileSizeAsyncInternal = getFileSizeAsync;\n    }\n\n    if (xhrIsAvailable) {\n      this._requestFileSyncInternal = syncDownloadFile;\n      this._requestFileSizeSyncInternal = getFileSizeSync;\n    } else {\n      this._requestFileSyncInternal = syncNotAvailableError;\n      this._requestFileSizeSyncInternal = syncNotAvailableError;\n    }\n  }\n\n  public empty(): void {\n    this._index.fileIterator(function(file: Stats) {\n      file.fileData = null;\n    });\n  }\n\n  public getName(): string {\n    return HTTPRequest.Name;\n  }\n\n  public diskSpace(path: string, cb: (total: number, free: number) => void): void {\n    // Read-only file system. We could calculate the total space, but that's not\n    // important right now.\n    cb(0, 0);\n  }\n\n  public isReadOnly(): boolean {\n    return true;\n  }\n\n  public supportsLinks(): boolean {\n    return false;\n  }\n\n  public supportsProps(): boolean {\n    return false;\n  }\n\n  public supportsSynch(): boolean {\n    // Synchronous operations are only available via the XHR interface for now.\n    return xhrIsAvailable;\n  }\n\n  /**\n   * Special HTTPFS function: Preload the given file into the index.\n   * @param [String] path\n   * @param [BrowserFS.Buffer] buffer\n   */\n  public preloadFile(path: string, buffer: Buffer): void {\n    const inode = this._index.getInode(path);\n    if (isFileInode<Stats>(inode)) {\n      if (inode === null) {\n        throw ApiError.ENOENT(path);\n      }\n      const stats = inode.getData();\n      stats.size = buffer.length;\n      stats.fileData = buffer;\n    } else {\n      throw ApiError.EISDIR(path);\n    }\n  }\n\n  public stat(path: string, isLstat: boolean, cb: BFSCallback<Stats>): void {\n    const inode = this._index.getInode(path);\n    if (inode === null) {\n      return cb(ApiError.ENOENT(path));\n    }\n    let stats: Stats;\n    if (isFileInode<Stats>(inode)) {\n      stats = inode.getData();\n      // At this point, a non-opened file will still have default stats from the listing.\n      if (stats.size < 0) {\n        this._requestFileSizeAsync(path, function(e: ApiError, size?: number) {\n          if (e) {\n            return cb(e);\n          }\n          stats.size = size!;\n          cb(null, Stats.clone(stats));\n        });\n      } else {\n        cb(null, Stats.clone(stats));\n      }\n    } else if (isDirInode(inode)) {\n      stats = inode.getStats();\n      cb(null, stats);\n    } else {\n      cb(ApiError.FileError(ErrorCode.EINVAL, path));\n    }\n  }\n\n  public statSync(path: string, isLstat: boolean): Stats {\n    const inode = this._index.getInode(path);\n    if (inode === null) {\n      throw ApiError.ENOENT(path);\n    }\n    let stats: Stats;\n    if (isFileInode<Stats>(inode)) {\n      stats = inode.getData();\n      // At this point, a non-opened file will still have default stats from the listing.\n      if (stats.size < 0) {\n        stats.size = this._requestFileSizeSync(path);\n      }\n    } else if (isDirInode(inode)) {\n      stats = inode.getStats();\n    } else {\n      throw ApiError.FileError(ErrorCode.EINVAL, path);\n    }\n    return stats;\n  }\n\n  public open(path: string, flags: FileFlag, mode: number, cb: BFSCallback<File>): void {\n    // INVARIANT: You can't write to files on this file system.\n    if (flags.isWriteable()) {\n      return cb(new ApiError(ErrorCode.EPERM, path));\n    }\n    const self = this;\n    // Check if the path exists, and is a file.\n    const inode = this._index.getInode(path);\n    if (inode === null) {\n      return cb(ApiError.ENOENT(path));\n    }\n    if (isFileInode<Stats>(inode)) {\n      const stats = inode.getData();\n      switch (flags.pathExistsAction()) {\n        case ActionType.THROW_EXCEPTION:\n        case ActionType.TRUNCATE_FILE:\n          return cb(ApiError.EEXIST(path));\n        case ActionType.NOP:\n          // Use existing file contents.\n          // XXX: Uh, this maintains the previously-used flag.\n          if (stats.fileData) {\n            return cb(null, new NoSyncFile(self, path, flags, Stats.clone(stats), stats.fileData));\n          }\n          // @todo be lazier about actually requesting the file\n          this._requestFileAsync(path, 'buffer', function(err: ApiError, buffer?: Buffer) {\n            if (err) {\n              return cb(err);\n            }\n            // we don't initially have file sizes\n            stats.size = buffer!.length;\n            stats.fileData = buffer!;\n            return cb(null, new NoSyncFile(self, path, flags, Stats.clone(stats), buffer));\n          });\n          break;\n        default:\n          return cb(new ApiError(ErrorCode.EINVAL, 'Invalid FileMode object.'));\n      }\n    } else {\n      return cb(ApiError.EISDIR(path));\n    }\n  }\n\n  public openSync(path: string, flags: FileFlag, mode: number): File {\n    // INVARIANT: You can't write to files on this file system.\n    if (flags.isWriteable()) {\n      throw new ApiError(ErrorCode.EPERM, path);\n    }\n    // Check if the path exists, and is a file.\n    const inode = this._index.getInode(path);\n    if (inode === null) {\n      throw ApiError.ENOENT(path);\n    }\n    if (isFileInode<Stats>(inode)) {\n      const stats = inode.getData();\n      switch (flags.pathExistsAction()) {\n        case ActionType.THROW_EXCEPTION:\n        case ActionType.TRUNCATE_FILE:\n          throw ApiError.EEXIST(path);\n        case ActionType.NOP:\n          // Use existing file contents.\n          // XXX: Uh, this maintains the previously-used flag.\n          if (stats.fileData) {\n            return new NoSyncFile(this, path, flags, Stats.clone(stats), stats.fileData);\n          }\n          // @todo be lazier about actually requesting the file\n          const buffer = this._requestFileSync(path, 'buffer');\n          // we don't initially have file sizes\n          stats.size = buffer.length;\n          stats.fileData = buffer;\n          return new NoSyncFile(this, path, flags, Stats.clone(stats), buffer);\n        default:\n          throw new ApiError(ErrorCode.EINVAL, 'Invalid FileMode object.');\n      }\n    } else {\n      throw ApiError.EISDIR(path);\n    }\n  }\n\n  public readdir(path: string, cb: BFSCallback<string[]>): void {\n    try {\n      cb(null, this.readdirSync(path));\n    } catch (e) {\n      cb(e);\n    }\n  }\n\n  public readdirSync(path: string): string[] {\n    // Check if it exists.\n    const inode = this._index.getInode(path);\n    if (inode === null) {\n      throw ApiError.ENOENT(path);\n    } else if (isDirInode(inode)) {\n      return inode.getListing();\n    } else {\n      throw ApiError.ENOTDIR(path);\n    }\n  }\n\n  /**\n   * We have the entire file as a buffer; optimize readFile.\n   */\n  public readFile(fname: string, encoding: string, flag: FileFlag, cb: BFSCallback<string | Buffer>): void {\n    // Wrap cb in file closing code.\n    const oldCb = cb;\n    // Get file.\n    this.open(fname, flag, 0x1a4, function(err: ApiError, fd?: File) {\n      if (err) {\n        return cb(err);\n      }\n      cb = function(err: ApiError, arg?: Buffer) {\n        fd!.close(function(err2: any) {\n          if (!err) {\n            err = err2;\n          }\n          return oldCb(err, arg);\n        });\n      };\n      const fdCast = <NoSyncFile<HTTPRequest>> fd;\n      const fdBuff = <Buffer> fdCast.getBuffer();\n      if (encoding === null) {\n        cb(err, copyingSlice(fdBuff));\n      } else {\n        tryToString(fdBuff, encoding, cb);\n      }\n    });\n  }\n\n  /**\n   * Specially-optimized readfile.\n   */\n  public readFileSync(fname: string, encoding: string, flag: FileFlag): any {\n    // Get file.\n    const fd = this.openSync(fname, flag, 0x1a4);\n    try {\n      const fdCast = <NoSyncFile<HTTPRequest>> fd;\n      const fdBuff = <Buffer> fdCast.getBuffer();\n      if (encoding === null) {\n        return copyingSlice(fdBuff);\n      }\n      return fdBuff.toString(encoding);\n    } finally {\n      fd.closeSync();\n    }\n  }\n\n  private _getHTTPPath(filePath: string): string {\n    if (filePath.charAt(0) === '/') {\n      filePath = filePath.slice(1);\n    }\n    return this.prefixUrl + filePath;\n  }\n\n  /**\n   * Asynchronously download the given file.\n   */\n  private _requestFileAsync(p: string, type: 'buffer', cb: BFSCallback<Buffer>): void;\n  private _requestFileAsync(p: string, type: 'json', cb: BFSCallback<any>): void;\n  private _requestFileAsync(p: string, type: string, cb: BFSCallback<any>): void;\n  private _requestFileAsync(p: string, type: string, cb: BFSCallback<any>): void {\n    this._requestFileAsyncInternal(this._getHTTPPath(p), type, cb);\n  }\n\n  /**\n   * Synchronously download the given file.\n   */\n  private _requestFileSync(p: string, type: 'buffer'): Buffer;\n  private _requestFileSync(p: string, type: 'json'): any;\n  private _requestFileSync(p: string, type: string): any;\n  private _requestFileSync(p: string, type: string): any {\n    return this._requestFileSyncInternal(this._getHTTPPath(p), type);\n  }\n\n  /**\n   * Only requests the HEAD content, for the file size.\n   */\n  private _requestFileSizeAsync(path: string, cb: BFSCallback<number>): void {\n    this._requestFileSizeAsyncInternal(this._getHTTPPath(path), cb);\n  }\n\n  private _requestFileSizeSync(path: string): number {\n    return this._requestFileSizeSyncInternal(this._getHTTPPath(path));\n  }\n}\n"]}