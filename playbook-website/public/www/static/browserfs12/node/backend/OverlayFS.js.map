{"version":3,"file":"OverlayFS.js","sourceRoot":"","sources":["../../../src/backend/OverlayFS.ts"],"names":[],"mappings":"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","sourcesContent":["import {FileSystem, BaseFileSystem, BFSOneArgCallback, BFSCallback, FileSystemOptions} from '../core/file_system';\nimport {ApiError, ErrorCode} from '../core/api_error';\nimport {FileFlag, ActionType} from '../core/file_flag';\nimport {File} from '../core/file';\nimport {default as Stats} from '../core/node_fs_stats';\nimport PreloadFile from '../generic/preload_file';\nimport LockedFS from '../generic/locked_fs';\nimport * as path from 'path';\n/**\n * @hidden\n */\nconst deletionLogPath = '/.deletedFiles.log';\n\n/**\n * Given a read-only mode, makes it writable.\n * @hidden\n */\nfunction makeModeWritable(mode: number): number {\n  return 0o222 | mode;\n}\n\n/**\n * @hidden\n */\nfunction getFlag(f: string): FileFlag {\n  return FileFlag.getFileFlag(f);\n}\n\n/**\n * Overlays a RO file to make it writable.\n */\nclass OverlayFile extends PreloadFile<UnlockedOverlayFS> implements File {\n  constructor(fs: UnlockedOverlayFS, path: string, flag: FileFlag, stats: Stats, data: Buffer) {\n    super(fs, path, flag, stats, data);\n  }\n\n  public sync(cb: BFSOneArgCallback): void {\n    if (!this.isDirty()) {\n      cb(null);\n      return;\n    }\n\n    this._fs._syncAsync(this, (err: ApiError) => {\n      this.resetDirty();\n      cb(err);\n    });\n  }\n\n  public syncSync(): void {\n    if (this.isDirty()) {\n      this._fs._syncSync(this);\n      this.resetDirty();\n    }\n  }\n\n  public close(cb: BFSOneArgCallback): void {\n    this.sync(cb);\n  }\n\n  public closeSync(): void {\n    this.syncSync();\n  }\n}\n\n/**\n * *INTERNAL, DO NOT USE DIRECTLY!*\n *\n * Core OverlayFS class that contains no locking whatsoever. We wrap these objects\n * in a LockedFS to prevent races.\n */\nexport class UnlockedOverlayFS extends BaseFileSystem implements FileSystem {\n  public static isAvailable(): boolean {\n    return true;\n  }\n\n  private _writable: FileSystem;\n  private _readable: FileSystem;\n  private _isInitialized: boolean = false;\n  private _initializeCallbacks: (BFSOneArgCallback)[] = [];\n  private _deletedFiles: {[path: string]: boolean} = {};\n  private _deleteLog: string = '';\n  // If 'true', we have scheduled a delete log update.\n  private _deleteLogUpdatePending: boolean = false;\n  // If 'true', a delete log update is needed after the scheduled delete log\n  // update finishes.\n  private _deleteLogUpdateNeeded: boolean = false;\n  // If there was an error updating the delete log...\n  private _deleteLogError: ApiError | null = null;\n\n  constructor(writable: FileSystem, readable: FileSystem) {\n    super();\n    this._writable = writable;\n    this._readable = readable;\n    if (this._writable.isReadOnly()) {\n      throw new ApiError(ErrorCode.EINVAL, \"Writable file system must be writable.\");\n    }\n  }\n\n  public getOverlayedFileSystems(): { readable: FileSystem; writable: FileSystem; } {\n    return {\n      readable: this._readable,\n      writable: this._writable\n    };\n  }\n\n  public _syncAsync(file: PreloadFile<UnlockedOverlayFS>, cb: BFSOneArgCallback): void {\n    this.createParentDirectoriesAsync(file.getPath(), (err?: ApiError) => {\n      if (err) {\n        return cb(err);\n      }\n      this._writable.writeFile(file.getPath(), file.getBuffer(), null, getFlag('w'), file.getStats().mode, cb);\n    });\n  }\n\n  public _syncSync(file: PreloadFile<UnlockedOverlayFS>): void {\n    this.createParentDirectories(file.getPath());\n    this._writable.writeFileSync(file.getPath(), file.getBuffer(), null, getFlag('w'), file.getStats().mode);\n  }\n\n  public getName() {\n    return OverlayFS.Name;\n  }\n\n  /**\n   * **INTERNAL METHOD**\n   *\n   * Called once to load up metadata stored on the writable file system.\n   */\n  public _initialize(cb: BFSOneArgCallback): void {\n    const callbackArray = this._initializeCallbacks;\n\n    const end = (e?: ApiError): void => {\n      this._isInitialized = !e;\n      this._initializeCallbacks = [];\n      callbackArray.forEach(((cb) => cb(e)));\n    };\n\n    // if we're already initialized, immediately invoke the callback\n    if (this._isInitialized) {\n      return cb();\n    }\n\n    callbackArray.push(cb);\n    // The first call to initialize initializes, the rest wait for it to complete.\n    if (callbackArray.length !== 1) {\n      return;\n    }\n\n    // Read deletion log, process into metadata.\n    this._writable.readFile(deletionLogPath, 'utf8', getFlag('r'), (err: ApiError, data?: string) => {\n      if (err) {\n        // ENOENT === Newly-instantiated file system, and thus empty log.\n        if (err.errno !== ErrorCode.ENOENT) {\n          return end(err);\n        }\n      } else {\n        this._deleteLog = data!;\n      }\n      this._reparseDeletionLog();\n      end();\n    });\n  }\n\n  public isReadOnly(): boolean { return false; }\n  public supportsSynch(): boolean { return this._readable.supportsSynch() && this._writable.supportsSynch(); }\n  public supportsLinks(): boolean { return false; }\n  public supportsProps(): boolean { return this._readable.supportsProps() && this._writable.supportsProps(); }\n\n  public getDeletionLog(): string {\n    return this._deleteLog;\n  }\n\n  public restoreDeletionLog(log: string): void {\n    this._deleteLog = log;\n    this._reparseDeletionLog();\n    this.updateLog('');\n  }\n\n  public rename(oldPath: string, newPath: string, cb: BFSOneArgCallback): void {\n    if (!this.checkInitAsync(cb) || this.checkPathAsync(oldPath, cb) || this.checkPathAsync(newPath, cb)) {\n      return;\n    }\n\n    if (oldPath === deletionLogPath || newPath === deletionLogPath) {\n      return cb(ApiError.EPERM('Cannot rename deletion log.'));\n    }\n\n    // nothing to do if paths match\n    if (oldPath === newPath) {\n      return cb();\n    }\n\n    this.stat(oldPath, false, (oldErr: ApiError, oldStats?: Stats) => {\n      if (oldErr) {\n        return cb(oldErr);\n      }\n\n      return this.stat(newPath, false, (newErr: ApiError, newStats?: Stats) => {\n        const self = this;\n        // precondition: both oldPath and newPath exist and are dirs.\n        // decreases: |files|\n        // Need to move *every file/folder* currently stored on\n        // readable to its new location on writable.\n        function copyDirContents(files: string[]): void {\n          const file = files.shift();\n          if (!file) {\n            return cb();\n          }\n\n          const oldFile = path.resolve(oldPath, file);\n          const newFile = path.resolve(newPath, file);\n\n          // Recursion! Should work for any nested files / folders.\n          self.rename(oldFile, newFile, (err?: ApiError) => {\n            if (err) {\n              return cb(err);\n            }\n            copyDirContents(files);\n          });\n        }\n\n        let mode = 0o777;\n\n        // from linux's rename(2) manpage: oldpath can specify a\n        // directory.  In this case, newpath must either not exist, or\n        // it must specify an empty directory.\n        if (oldStats!.isDirectory()) {\n          if (newErr) {\n            if (newErr.errno !== ErrorCode.ENOENT) {\n              return cb(newErr);\n            }\n\n            return this._writable.exists(oldPath, (exists: boolean) => {\n              // simple case - both old and new are on the writable layer\n              if (exists) {\n                return this._writable.rename(oldPath, newPath, cb);\n              }\n\n              this._writable.mkdir(newPath, mode, (mkdirErr?: ApiError) => {\n                if (mkdirErr) {\n                  return cb(mkdirErr);\n                }\n\n                this._readable.readdir(oldPath, (err: ApiError, files?: string[]) => {\n                  if (err) {\n                    return cb();\n                  }\n                  copyDirContents(files!);\n                });\n              });\n            });\n          }\n\n          mode = newStats!.mode;\n          if (!newStats!.isDirectory()) {\n            return cb(ApiError.ENOTDIR(newPath));\n          }\n\n          this.readdir(newPath, (readdirErr: ApiError, files?: string[]) => {\n            if (files && files.length) {\n              return cb(ApiError.ENOTEMPTY(newPath));\n            }\n\n            this._readable.readdir(oldPath, (err: ApiError, files?: string[]) => {\n              if (err) {\n                return cb();\n              }\n              copyDirContents(files!);\n            });\n          });\n        }\n\n        if (newStats && newStats.isDirectory()) {\n          return cb(ApiError.EISDIR(newPath));\n        }\n\n        this.readFile(oldPath, null, getFlag('r'), (err: ApiError, data?: any) => {\n          if (err) {\n            return cb(err);\n          }\n\n          return this.writeFile(newPath, data, null, getFlag('w'), oldStats!.mode, (err: ApiError) => {\n            if (err) {\n              return cb(err);\n            }\n            return this.unlink(oldPath, cb);\n          });\n        });\n      });\n    });\n  }\n\n  public renameSync(oldPath: string, newPath: string): void {\n    this.checkInitialized();\n    this.checkPath(oldPath);\n    this.checkPath(newPath);\n    if (oldPath === deletionLogPath || newPath === deletionLogPath) {\n      throw ApiError.EPERM('Cannot rename deletion log.');\n    }\n    // Write newPath using oldPath's contents, delete oldPath.\n    const oldStats = this.statSync(oldPath, false);\n    if (oldStats.isDirectory()) {\n      // Optimization: Don't bother moving if old === new.\n      if (oldPath === newPath) {\n        return;\n      }\n\n      let mode = 0o777;\n      if (this.existsSync(newPath)) {\n        const stats = this.statSync(newPath, false);\n        mode = stats.mode;\n        if (stats.isDirectory()) {\n          if (this.readdirSync(newPath).length > 0) {\n            throw ApiError.ENOTEMPTY(newPath);\n          }\n        } else {\n          throw ApiError.ENOTDIR(newPath);\n        }\n      }\n\n      // Take care of writable first. Move any files there, or create an empty directory\n      // if it doesn't exist.\n      if (this._writable.existsSync(oldPath)) {\n        this._writable.renameSync(oldPath, newPath);\n      } else if (!this._writable.existsSync(newPath)) {\n        this._writable.mkdirSync(newPath, mode);\n      }\n\n      // Need to move *every file/folder* currently stored on readable to its new location\n      // on writable.\n      if (this._readable.existsSync(oldPath)) {\n        this._readable.readdirSync(oldPath).forEach((name) => {\n          // Recursion! Should work for any nested files / folders.\n          this.renameSync(path.resolve(oldPath, name), path.resolve(newPath, name));\n        });\n      }\n    } else {\n      if (this.existsSync(newPath) && this.statSync(newPath, false).isDirectory()) {\n        throw ApiError.EISDIR(newPath);\n      }\n\n      this.writeFileSync(newPath,\n        this.readFileSync(oldPath, null, getFlag('r')), null, getFlag('w'), oldStats.mode);\n    }\n\n    if (oldPath !== newPath && this.existsSync(oldPath)) {\n      this.unlinkSync(oldPath);\n    }\n  }\n\n  public stat(p: string, isLstat: boolean, cb: BFSCallback<Stats>): void {\n    if (!this.checkInitAsync(cb)) {\n      return;\n    }\n    this._writable.stat(p, isLstat, (err: ApiError, stat?: Stats) => {\n      if (err && err.errno === ErrorCode.ENOENT) {\n        if (this._deletedFiles[p]) {\n          cb(ApiError.ENOENT(p));\n        }\n        this._readable.stat(p, isLstat, (err: ApiError, stat?: Stats) => {\n          if (stat) {\n            // Make the oldStat's mode writable. Preserve the topmost\n            // part of the mode, which specifies if it is a file or a\n            // directory.\n            stat = Stats.clone(stat);\n            stat.mode = makeModeWritable(stat.mode);\n          }\n          cb(err, stat);\n        });\n      } else {\n        cb(err, stat);\n      }\n    });\n  }\n\n  public statSync(p: string, isLstat: boolean): Stats {\n    this.checkInitialized();\n    try {\n      return this._writable.statSync(p, isLstat);\n    } catch (e) {\n      if (this._deletedFiles[p]) {\n        throw ApiError.ENOENT(p);\n      }\n      const oldStat = Stats.clone(this._readable.statSync(p, isLstat));\n      // Make the oldStat's mode writable. Preserve the topmost part of the\n      // mode, which specifies if it is a file or a directory.\n      oldStat.mode = makeModeWritable(oldStat.mode);\n      return oldStat;\n    }\n  }\n\n  public open(p: string, flag: FileFlag, mode: number, cb: BFSCallback<File>): void {\n    if (!this.checkInitAsync(cb) || this.checkPathAsync(p, cb)) {\n      return;\n    }\n    this.stat(p, false, (err: ApiError, stats?: Stats) => {\n      if (stats) {\n        switch (flag.pathExistsAction()) {\n        case ActionType.TRUNCATE_FILE:\n          return this.createParentDirectoriesAsync(p, (err?: ApiError) => {\n            if (err) {\n              return cb(err);\n            }\n            this._writable.open(p, flag, mode, cb);\n          });\n        case ActionType.NOP:\n          return this._writable.exists(p, (exists: boolean) => {\n            if (exists) {\n              this._writable.open(p, flag, mode, cb);\n            } else {\n              // at this point we know the stats object we got is from\n              // the readable FS.\n              stats = Stats.clone(stats!);\n              stats.mode = mode;\n              this._readable.readFile(p, null, getFlag('r'), (readFileErr: ApiError, data?: any) => {\n                if (readFileErr) {\n                  return cb(readFileErr);\n                }\n                if (stats!.size === -1) {\n                  stats!.size = data.length;\n                }\n                const f = new OverlayFile(this, p, flag, stats!, data);\n                cb(null, f);\n              });\n            }\n          });\n        default:\n          return cb(ApiError.EEXIST(p));\n        }\n      } else {\n        switch (flag.pathNotExistsAction()) {\n        case ActionType.CREATE_FILE:\n          return this.createParentDirectoriesAsync(p, (err?: ApiError) => {\n            if (err) {\n              return cb(err);\n            }\n            return this._writable.open(p, flag, mode, cb);\n          });\n        default:\n          return cb(ApiError.ENOENT(p));\n        }\n      }\n    });\n  }\n\n  public openSync(p: string, flag: FileFlag, mode: number): File {\n    this.checkInitialized();\n    this.checkPath(p);\n    if (p === deletionLogPath) {\n      throw ApiError.EPERM('Cannot open deletion log.');\n    }\n    if (this.existsSync(p)) {\n      switch (flag.pathExistsAction()) {\n        case ActionType.TRUNCATE_FILE:\n          this.createParentDirectories(p);\n          return this._writable.openSync(p, flag, mode);\n        case ActionType.NOP:\n          if (this._writable.existsSync(p)) {\n            return this._writable.openSync(p, flag, mode);\n          } else {\n            // Create an OverlayFile.\n            const buf = this._readable.readFileSync(p, null, getFlag('r'));\n            const stats = Stats.clone(this._readable.statSync(p, false));\n            stats.mode = mode;\n            return new OverlayFile(this, p, flag, stats, buf);\n          }\n        default:\n          throw ApiError.EEXIST(p);\n      }\n    } else {\n      switch (flag.pathNotExistsAction()) {\n        case ActionType.CREATE_FILE:\n          this.createParentDirectories(p);\n          return this._writable.openSync(p, flag, mode);\n        default:\n          throw ApiError.ENOENT(p);\n      }\n    }\n  }\n\n  public unlink(p: string, cb: BFSOneArgCallback): void {\n    if (!this.checkInitAsync(cb) || this.checkPathAsync(p, cb)) {\n      return;\n    }\n    this.exists(p, (exists: boolean) => {\n      if (!exists) {\n        return cb(ApiError.ENOENT(p));\n      }\n\n      this._writable.exists(p, (writableExists: boolean) => {\n        if (writableExists) {\n          return this._writable.unlink(p, (err: ApiError) => {\n            if (err) {\n              return cb(err);\n            }\n\n            this.exists(p, (readableExists: boolean) => {\n              if (readableExists) {\n                this.deletePath(p);\n              }\n              cb(null);\n            });\n          });\n        } else {\n          // if this only exists on the readable FS, add it to the\n          // delete map.\n          this.deletePath(p);\n          cb(null);\n        }\n      });\n    });\n  }\n\n  public unlinkSync(p: string): void {\n    this.checkInitialized();\n    this.checkPath(p);\n    if (this.existsSync(p)) {\n      if (this._writable.existsSync(p)) {\n        this._writable.unlinkSync(p);\n      }\n\n      // if it still exists add to the delete log\n      if (this.existsSync(p)) {\n        this.deletePath(p);\n      }\n    } else {\n      throw ApiError.ENOENT(p);\n    }\n  }\n\n  public rmdir(p: string, cb: BFSOneArgCallback): void {\n    if (!this.checkInitAsync(cb)) {\n      return;\n    }\n\n    const rmdirLower = (): void => {\n      this.readdir(p, (err: ApiError, files: string[]): void => {\n        if (err) {\n          return cb(err);\n        }\n\n        if (files.length) {\n          return cb(ApiError.ENOTEMPTY(p));\n        }\n\n        this.deletePath(p);\n        cb(null);\n      });\n    };\n\n    this.exists(p, (exists: boolean) => {\n      if (!exists) {\n        return cb(ApiError.ENOENT(p));\n      }\n\n      this._writable.exists(p, (writableExists: boolean) => {\n        if (writableExists) {\n          this._writable.rmdir(p, (err: ApiError) => {\n            if (err) {\n              return cb(err);\n            }\n\n            this._readable.exists(p, (readableExists: boolean) => {\n              if (readableExists) {\n                rmdirLower();\n              } else {\n                cb();\n              }\n            });\n          });\n        } else {\n          rmdirLower();\n        }\n      });\n    });\n  }\n\n  public rmdirSync(p: string): void {\n    this.checkInitialized();\n    if (this.existsSync(p)) {\n      if (this._writable.existsSync(p)) {\n        this._writable.rmdirSync(p);\n      }\n      if (this.existsSync(p)) {\n        // Check if directory is empty.\n        if (this.readdirSync(p).length > 0) {\n          throw ApiError.ENOTEMPTY(p);\n        } else {\n          this.deletePath(p);\n        }\n      }\n    } else {\n      throw ApiError.ENOENT(p);\n    }\n  }\n\n  public mkdir(p: string, mode: number, cb: BFSCallback<Stats>): void {\n    if (!this.checkInitAsync(cb)) {\n      return;\n    }\n    this.exists(p, (exists: boolean) => {\n      if (exists) {\n        return cb(ApiError.EEXIST(p));\n      }\n\n      // The below will throw should any of the parent directories\n      // fail to exist on _writable.\n      this.createParentDirectoriesAsync(p, (err: ApiError) => {\n        if (err) {\n          return cb(err);\n        }\n        this._writable.mkdir(p, mode, cb);\n      });\n    });\n  }\n\n  public mkdirSync(p: string, mode: number): void {\n    this.checkInitialized();\n    if (this.existsSync(p)) {\n      throw ApiError.EEXIST(p);\n    } else {\n      // The below will throw should any of the parent directories fail to exist\n      // on _writable.\n      this.createParentDirectories(p);\n      this._writable.mkdirSync(p, mode);\n    }\n  }\n\n  public readdir(p: string, cb: BFSCallback<string[]>): void {\n    if (!this.checkInitAsync(cb)) {\n      return;\n    }\n    this.stat(p, false, (err: ApiError, dirStats?: Stats) => {\n      if (err) {\n        return cb(err);\n      }\n\n      if (!dirStats!.isDirectory()) {\n        return cb(ApiError.ENOTDIR(p));\n      }\n\n      this._writable.readdir(p, (err: ApiError, wFiles: string[]) => {\n        if (err && err.code !== 'ENOENT') {\n          return cb(err);\n        } else if (err || !wFiles) {\n          wFiles = [];\n        }\n\n        this._readable.readdir(p, (err: ApiError, rFiles: string[]) => {\n          // if the directory doesn't exist on the lower FS set rFiles\n          // here to simplify the following code.\n          if (err || !rFiles) {\n            rFiles = [];\n          }\n\n          // Readdir in both, check delete log on read-only file system's files, merge, return.\n          const seenMap: {[name: string]: boolean} = {};\n          const filtered: string[] = wFiles.concat(rFiles.filter((fPath: string) =>\n            !this._deletedFiles[`${p}/${fPath}`]\n          )).filter((fPath: string) => {\n            // Remove duplicates.\n            const result = !seenMap[fPath];\n            seenMap[fPath] = true;\n            return result;\n          });\n          cb(null, filtered);\n        });\n      });\n    });\n  }\n\n  public readdirSync(p: string): string[] {\n    this.checkInitialized();\n    const dirStats = this.statSync(p, false);\n    if (!dirStats.isDirectory()) {\n      throw ApiError.ENOTDIR(p);\n    }\n\n    // Readdir in both, check delete log on RO file system's listing, merge, return.\n    let contents: string[] = [];\n    try {\n      contents = contents.concat(this._writable.readdirSync(p));\n    } catch (e) {\n      // NOP.\n    }\n    try {\n      contents = contents.concat(this._readable.readdirSync(p).filter((fPath: string) =>\n        !this._deletedFiles[`${p}/${fPath}`]\n      ));\n    } catch (e) {\n      // NOP.\n    }\n    const seenMap: {[name: string]: boolean} = {};\n    return contents.filter((fileP: string) => {\n      const result = !seenMap[fileP];\n      seenMap[fileP] = true;\n      return result;\n    });\n  }\n\n  public exists(p: string, cb: (exists: boolean) => void): void {\n    // Cannot pass an error back to callback, so throw an exception instead\n    // if not initialized.\n    this.checkInitialized();\n    this._writable.exists(p, (existsWritable: boolean) => {\n      if (existsWritable) {\n        return cb(true);\n      }\n\n      this._readable.exists(p, (existsReadable: boolean) => {\n        cb(existsReadable && this._deletedFiles[p] !== true);\n      });\n    });\n  }\n\n  public existsSync(p: string): boolean {\n    this.checkInitialized();\n    return this._writable.existsSync(p) || (this._readable.existsSync(p) && this._deletedFiles[p] !== true);\n  }\n\n  public chmod(p: string, isLchmod: boolean, mode: number, cb: BFSOneArgCallback): void {\n    if (!this.checkInitAsync(cb)) {\n      return;\n    }\n    this.operateOnWritableAsync(p, (err?: ApiError) => {\n      if (err) {\n        return cb(err);\n      } else {\n        this._writable.chmod(p, isLchmod, mode, cb);\n      }\n    });\n  }\n\n  public chmodSync(p: string, isLchmod: boolean, mode: number): void {\n    this.checkInitialized();\n    this.operateOnWritable(p, () => {\n      this._writable.chmodSync(p, isLchmod, mode);\n    });\n  }\n\n  public chown(p: string, isLchmod: boolean, uid: number, gid: number, cb: BFSOneArgCallback): void {\n    if (!this.checkInitAsync(cb)) {\n      return;\n    }\n    this.operateOnWritableAsync(p, (err?: ApiError) => {\n      if (err) {\n        return cb(err);\n      } else {\n        this._writable.chown(p, isLchmod, uid, gid, cb);\n      }\n    });\n  }\n\n  public chownSync(p: string, isLchown: boolean, uid: number, gid: number): void {\n    this.checkInitialized();\n    this.operateOnWritable(p, () => {\n      this._writable.chownSync(p, isLchown, uid, gid);\n    });\n  }\n\n  public utimes(p: string, atime: Date, mtime: Date, cb: BFSOneArgCallback): void {\n    if (!this.checkInitAsync(cb)) {\n      return;\n    }\n    this.operateOnWritableAsync(p, (err?: ApiError) => {\n      if (err) {\n        return cb(err);\n      } else {\n        this._writable.utimes(p, atime, mtime, cb);\n      }\n    });\n  }\n\n  public utimesSync(p: string, atime: Date, mtime: Date): void {\n    this.checkInitialized();\n    this.operateOnWritable(p, () => {\n      this._writable.utimesSync(p, atime, mtime);\n    });\n  }\n\n  private deletePath(p: string): void {\n    this._deletedFiles[p] = true;\n    this.updateLog(`d${p}\\n`);\n  }\n\n  private updateLog(addition: string) {\n    this._deleteLog += addition;\n    if (this._deleteLogUpdatePending) {\n      this._deleteLogUpdateNeeded = true;\n    } else {\n      this._deleteLogUpdatePending = true;\n      this._writable.writeFile(deletionLogPath, this._deleteLog, 'utf8', FileFlag.getFileFlag('w'), 0o644, (e) => {\n        this._deleteLogUpdatePending = false;\n        if (e) {\n          this._deleteLogError = e;\n        } else if (this._deleteLogUpdateNeeded) {\n          this._deleteLogUpdateNeeded = false;\n          this.updateLog('');\n        }\n      });\n    }\n  }\n\n  private _reparseDeletionLog(): void {\n    this._deletedFiles = {};\n    this._deleteLog.split('\\n').forEach((path: string) => {\n      // If the log entry begins w/ 'd', it's a deletion.\n      this._deletedFiles[path.slice(1)] = path.slice(0, 1) === 'd';\n    });\n  }\n\n  private checkInitialized(): void {\n    if (!this._isInitialized) {\n      throw new ApiError(ErrorCode.EPERM, \"OverlayFS is not initialized. Please initialize OverlayFS using its initialize() method before using it.\");\n    } else if (this._deleteLogError !== null) {\n      const e = this._deleteLogError;\n      this._deleteLogError = null;\n      throw e;\n    }\n  }\n\n  private checkInitAsync(cb: BFSOneArgCallback): boolean {\n    if (!this._isInitialized) {\n      cb(new ApiError(ErrorCode.EPERM, \"OverlayFS is not initialized. Please initialize OverlayFS using its initialize() method before using it.\"));\n      return false;\n    } else if (this._deleteLogError !== null) {\n      const e = this._deleteLogError;\n      this._deleteLogError = null;\n      cb(e);\n      return false;\n    }\n    return true;\n  }\n\n  private checkPath(p: string): void {\n    if (p === deletionLogPath) {\n      throw ApiError.EPERM(p);\n    }\n  }\n\n  private checkPathAsync(p: string, cb: BFSOneArgCallback): boolean {\n    if (p === deletionLogPath) {\n      cb(ApiError.EPERM(p));\n      return true;\n    }\n    return false;\n  }\n\n  private createParentDirectoriesAsync(p: string, cb: BFSOneArgCallback): void {\n    let parent = path.dirname(p);\n    const toCreate: string[] = [];\n    const self = this;\n\n    this._writable.stat(parent, false, statDone);\n    function statDone(err: ApiError, stat?: Stats): void {\n      if (err) {\n        if (parent === \"/\") {\n          cb(new ApiError(ErrorCode.EBUSY, \"Invariant failed: root does not exist!\"));\n        } else {\n          toCreate.push(parent);\n          parent = path.dirname(parent);\n          self._writable.stat(parent, false, statDone);\n        }\n      } else {\n        createParents();\n      }\n    }\n\n    function createParents(): void {\n      if (!toCreate.length) {\n        return cb();\n      }\n\n      const dir = toCreate.pop();\n      self._readable.stat(dir!, false, (err: ApiError, stats?: Stats) => {\n        // stop if we couldn't read the dir\n        if (!stats) {\n          return cb();\n        }\n\n        self._writable.mkdir(dir!, stats.mode, (err?: ApiError) => {\n          if (err) {\n            return cb(err);\n          }\n          createParents();\n        });\n      });\n    }\n  }\n\n  /**\n   * With the given path, create the needed parent directories on the writable storage\n   * should they not exist. Use modes from the read-only storage.\n   */\n  private createParentDirectories(p: string): void {\n    let parent = path.dirname(p), toCreate: string[] = [];\n    while (!this._writable.existsSync(parent)) {\n      toCreate.push(parent);\n      parent = path.dirname(parent);\n    }\n    toCreate = toCreate.reverse();\n\n    toCreate.forEach((p: string) => {\n      this._writable.mkdirSync(p, this.statSync(p, false).mode);\n    });\n  }\n\n  /**\n   * Helper function:\n   * - Ensures p is on writable before proceeding. Throws an error if it doesn't exist.\n   * - Calls f to perform operation on writable.\n   */\n  private operateOnWritable(p: string, f: () => void): void {\n    if (this.existsSync(p)) {\n      if (!this._writable.existsSync(p)) {\n        // File is on readable storage. Copy to writable storage before\n        // changing its mode.\n        this.copyToWritable(p);\n      }\n      f();\n    } else {\n      throw ApiError.ENOENT(p);\n    }\n  }\n\n  private operateOnWritableAsync(p: string, cb: BFSOneArgCallback): void {\n    this.exists(p, (exists: boolean) => {\n      if (!exists) {\n        return cb(ApiError.ENOENT(p));\n      }\n\n      this._writable.exists(p, (existsWritable: boolean) => {\n        if (existsWritable) {\n          cb();\n        } else {\n          return this.copyToWritableAsync(p, cb);\n        }\n      });\n    });\n  }\n\n  /**\n   * Copy from readable to writable storage.\n   * PRECONDITION: File does not exist on writable storage.\n   */\n  private copyToWritable(p: string): void {\n    const pStats = this.statSync(p, false);\n    if (pStats.isDirectory()) {\n      this._writable.mkdirSync(p, pStats.mode);\n    } else {\n      this.writeFileSync(p,\n        this._readable.readFileSync(p, null, getFlag('r')), null,\n        getFlag('w'), this.statSync(p, false).mode);\n    }\n  }\n\n  private copyToWritableAsync(p: string, cb: BFSOneArgCallback): void {\n    this.stat(p, false, (err: ApiError, pStats?: Stats) => {\n      if (err) {\n        return cb(err);\n      }\n\n      if (pStats!.isDirectory()) {\n        return this._writable.mkdir(p, pStats!.mode, cb);\n      }\n\n      // need to copy file.\n      this._readable.readFile(p, null, getFlag('r'), (err: ApiError, data?: Buffer) => {\n        if (err) {\n          return cb(err);\n        }\n\n        this.writeFile(p, data, null, getFlag('w'), pStats!.mode, cb);\n      });\n    });\n  }\n}\n\n/**\n * Configuration options for OverlayFS instances.\n */\nexport interface OverlayFSOptions {\n  // The file system to write modified files to.\n  writable: FileSystem;\n  // The file system that initially populates this file system.\n  readable: FileSystem;\n}\n\n/**\n * OverlayFS makes a read-only filesystem writable by storing writes on a second,\n * writable file system. Deletes are persisted via metadata stored on the writable\n * file system.\n */\nexport default class OverlayFS extends LockedFS<UnlockedOverlayFS> {\n  public static readonly Name = \"OverlayFS\";\n\n  public static readonly Options: FileSystemOptions = {\n    writable: {\n      type: \"object\",\n      description: \"The file system to write modified files to.\"\n    },\n    readable: {\n      type: \"object\",\n      description: \"The file system that initially populates this file system.\"\n    }\n  };\n\n  /**\n   * Constructs and initializes an OverlayFS instance with the given options.\n   */\n  public static Create(opts: OverlayFSOptions, cb: BFSCallback<OverlayFS>): void {\n    try {\n      const fs = new OverlayFS(opts.writable, opts.readable);\n      fs._initialize((e?) => {\n        cb(e, fs);\n      });\n    } catch (e) {\n      cb(e);\n    }\n  }\n  public static isAvailable(): boolean {\n    return UnlockedOverlayFS.isAvailable();\n  }\n\n  /**\n   * @param writable The file system to write modified files to.\n   * @param readable The file system that initially populates this file system.\n   */\n  constructor(writable: FileSystem, readable: FileSystem) {\n    super(new UnlockedOverlayFS(writable, readable));\n  }\n\n  public getOverlayedFileSystems(): { readable: FileSystem; writable: FileSystem; } {\n    return super.getFSUnlocked().getOverlayedFileSystems();\n  }\n\n  public unwrap(): UnlockedOverlayFS {\n    return super.getFSUnlocked();\n  }\n\n  private _initialize(cb: BFSOneArgCallback): void {\n    super.getFSUnlocked()._initialize(cb);\n  }\n}\n"]}