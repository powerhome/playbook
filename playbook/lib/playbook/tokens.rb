# frozen_string_literal: true

require "json"

module Playbook
  # Playbook design tokens for Rails. One JSON file per token type, generated by
  # scripts/generate-tokens.js (yarn generate:tokens, run from playbook/). Source: token SCSS + types.
  #
  # @example
  #   Playbook::Tokens.colors[:input_text_error]  # => "#DA0014"
  #   Playbook::Tokens.colors.input_text_error    # => "#DA0014"
  #
  # --- Current design ---
  # Only colors: tokens/colors.json (accessible keys from _colors.module.scss + types/colors.ts).
  # When you add or change accessible color tokens, run `yarn generate:tokens` and stage the updated
  # colors.json; otherwise Overcommit will run the generator on commit and fail until you do.
  #
  # --- Next steps for additional token types ---
  # - One JSON per type (tokens/typography.json, tokens/spacing.json, …) and one method per type below.
  # - For each new type: add a method (e.g. def typography) that loads the JSON and wraps in ColorHash
  #   (or a similar wrapper if the shape differs [TODO: Rename ColorHash to TokenHash if appropriate]).
  #   Add a reload_typography! (or reload_*!) if needed.
  # - Ensure generate-tokens.js is extended to write that JSON (same pattern: compile SCSS → extract → write).
  # - Update .overcommit.yml include paths and .git-hooks/pre_commit/verify_tokens.sh to compare the new
  #   generated file so commits stay in sync.
  #
  #   Example for typography:
  #     def typography
  #       @typography ||= ColorHash.new(JSON.parse(File.read(File.join(__dir__, "tokens", "typography.json")), symbolize_names: true))
  #     end
  #     def reload_typography!
  #       @typography = nil; typography
  #     end
  #
  module Tokens
    class << self
      # Load colors from generated tokens/colors.json (accessible keys only).
      #
      # @return [ColorHash] colors with both hash and method access
      def colors
        @colors ||= begin
          json_path = File.join(__dir__, "tokens", "colors.json")
          hash = JSON.parse(File.read(json_path), symbolize_names: true)
          ColorHash.new(hash)
        end
      end

      # Reload colors from JSON (useful after regenerating)
      def reload_colors!
        @colors = nil
        colors
      end
    end

    # Hash wrapper supporting colors[:key] and colors.key
    class ColorHash
      def initialize(hash)
        @hash = hash.freeze
      end

      def [](key)
        @hash[key.to_sym]
      end

      def method_missing(method_name, *args, &block)
        key = method_name.to_sym
        if @hash.key?(key)
          @hash[key]
        else
          super
        end
      end

      def respond_to_missing?(method_name, include_private = false)
        @hash.key?(method_name.to_sym) || super
      end

      def to_h
        @hash
      end

      alias to_hash to_h

      def keys
        @hash.keys
      end

      def values
        @hash.values
      end

      def key?(key)
        @hash.key?(key.to_sym)
      end

      alias has_key? key?
    end
  end
end
